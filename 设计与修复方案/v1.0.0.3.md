好的！我将推荐系统模块的完整设计方案输出到对话中：

---

# MyBilibili 推荐系统模块设计方案 v1.0.0.3

## 一、项目概述

### 1.1 目标
基于 Bilibili 主项目的 `recsys` 和 `recsys-recall` 模块，为 MyBilibili 实现完整的**三阶段推荐系统**：召回（Recall）→ 排序（Rank）→ 过滤（Filter）

### 1.2 核心要求
1. **只实现B站主站推荐**：不考虑 BBQ 短视频平台
2. **业务逻辑严格按照主项目**：保持核心推荐流程一致
3. **数据层严格按照主项目构建**：保持数据模型和存储结构一致
4. **模型兼容性**：适配 `train_v13_final.py` 导出的 XGBoost 模型（TreeLite Protobuf 格式）

### 1.3 技术栈
- **Go 1.16+**
- **go-zero** 微服务框架
- **Redis**: 用户画像缓存、召回索引、布隆过滤器
- **MySQL**: 视频数据、用户行为数据
- **XGBoost + TreeLite**: 排序模型
- **etcd**: 服务发现
- **Prometheus**: 监控指标

---

## 二、系统架构设计

### 2.1 总体架构

```
┌─────────────────────────────────────────────────────────────┐
│                     创作者 API 网关                          │
│                   (creative-api)                            │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        │ gRPC
                        ↓
┌─────────────────────────────────────────────────────────────┐
│              推荐系统服务 (recommend-rpc)                     │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  1. 用户画像加载 (User Profile)                       │  │
│  │     - 从 Redis 加载历史画像                           │  │
│  │     - 加载实时行为数据（点赞、观看、关注）             │  │
│  └──────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  2. 召回阶段 (Recall Stage) - 调用 recall-rpc        │  │
│  │     多路召回策略：                                    │  │
│  │     - 热门召回 (HotRecall)                            │  │
│  │     - 精选召回 (SelectionRecall)                      │  │
│  │     - 标签召回 (TagRecall)                            │  │
│  │     - I2I 协同过滤 (LikeI2IRecall)                    │  │
│  │     - UP主召回 (FollowRecall)                         │  │
│  │     - 用户画像召回 (UserProfileRecall)                │  │
│  │     召回数量: 500-1000 个候选视频                      │  │
│  └──────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  3. 初步过滤 (Pre-Filter)                            │  │
│  │     - 精确去重 (DefaultFilter)                        │  │
│  │     - 黑名单过滤 (BlackFilter)                        │  │
│  │     剩余: ~300-500 个                                  │  │
│  └──────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  4. 排序阶段 (Rank Stage)                            │  │
│  │     - 特征工程 (Feature Engineering)                  │  │
│  │       * 用户特征: 兴趣标签、观看历史                   │  │
│  │       * 视频特征: 播放量、点赞数、分区、时长           │  │
│  │       * 交叉特征: 用户-视频标签匹配度                  │  │
│  │       * 召回特征: 召回策略类型                         │  │
│  │     - XGBoost 模型预测 (v13)                          │  │
│  │       65个特征 → 点击率预测分数                        │  │
│  │     - 按分数排序                                      │  │
│  └──────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  5. 后处理 (Post-Process)                            │  │
│  │     - 布隆过滤器去重 (BloomFilter)                     │  │
│  │     - 时长过滤 (DurationFilter) 15-60秒               │  │
│  │     - 打散策略 (Scatter): 避免连续同UP主/同标签        │  │
│  └──────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  6. 分页返回                                          │  │
│  │     - 取 Top N (默认 20 个)                           │  │
│  │     - 记录推荐结果到 Redis（用于去重）                 │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                        │
                        │ gRPC 依赖
                        ↓
┌─────────────────────────────────────────────────────────────┐
│              召回服务 (recall-rpc)                           │
│                                                              │
│  - 多路召回并行执行                                           │
│  - 从 Redis 读取召回索引                                      │
│  - 合并去重，返回候选集                                       │
└─────────────────────────────────────────────────────────────┘
                        │
                        ↓
        ┌──────────────────────────────────┐
        │     数据层 (Data Layer)           │
        │  - Redis: 召回索引、用户画像       │
        │  - MySQL: 视频详情、用户行为       │
        └──────────────────────────────────┘
```

### 2.2 服务划分

#### 服务1: `recommend-rpc`（推荐主服务）
- **职责**: 完整的推荐流程编排
- **端口**: 9005 (RPC), 9095 (Metrics)
- **依赖**: recall-rpc, video-rpc, MySQL, Redis
- **核心模块**:
  - `service/recommend.go`: 推荐主流程
  - `service/rank/`: 排序模块
  - `service/filter.go`: 过滤模块
  - `service/postprocess/`: 后处理模块
  - `dao/`: 数据访问层

#### 服务2: `recall-rpc`（召回服务）
- **职责**: 多路召回策略执行
- **端口**: 9006 (RPC), 9096 (Metrics)
- **依赖**: Redis, MySQL
- **核心模块**:
  - `service/recall.go`: 召回主流程
  - `service/index/`: 索引服务（倒排索引、正排索引）
  - `service/bloomfilter.go`: 布隆过滤器
  - `service/score.go`: 召回打分器

---

## 三、数据层设计（严格按照主项目）

### 3.1 MySQL 数据表

#### 3.1.1 视频表 (`video_info`)
```sql
CREATE TABLE `video_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avid` bigint(20) NOT NULL COMMENT '视频AV号',
  `cid` bigint(20) NOT NULL COMMENT '分P的CID',
  `mid` bigint(20) NOT NULL COMMENT 'UP主MID',
  `title` varchar(255) NOT NULL COMMENT '视频标题',
  `cover` varchar(512) DEFAULT NULL COMMENT '封面URL',
  `duration` int(11) NOT NULL COMMENT '视频时长(秒)',
  `pub_time` bigint(20) NOT NULL COMMENT '发布时间戳',
  `zone_id` int(11) NOT NULL COMMENT '分区ID',
  `state` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态: 1-正常 3-回查可放出 4-优质 5-精选',
  
  -- 统计数据（全站）
  `play_hive` bigint(20) DEFAULT '0' COMMENT 'B站全站播放量',
  `likes_hive` bigint(20) DEFAULT '0' COMMENT 'B站全站点赞数',
  `fav_hive` bigint(20) DEFAULT '0' COMMENT 'B站全站收藏数',
  `share_hive` bigint(20) DEFAULT '0' COMMENT 'B站全站分享数',
  `coin_hive` bigint(20) DEFAULT '0' COMMENT 'B站全站投币数',
  `reply_hive` bigint(20) DEFAULT '0' COMMENT 'B站全站评论数',
  
  -- 统计数据（月度）
  `play_month` bigint(20) DEFAULT '0' COMMENT '近30天播放量',
  `likes_month` bigint(20) DEFAULT '0' COMMENT '近30天点赞数',
  `share_month` bigint(20) DEFAULT '0' COMMENT '近30天分享数',
  `reply_month` bigint(20) DEFAULT '0' COMMENT '近30天评论数',
  `play_month_finish` bigint(20) DEFAULT '0' COMMENT '近30天完播量',
  
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_avid` (`avid`),
  KEY `idx_mid` (`mid`),
  KEY `idx_zone` (`zone_id`),
  KEY `idx_state` (`state`),
  KEY `idx_pubtime` (`pub_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='视频信息表';
```

#### 3.1.2 视频标签表 (`video_tag`)
```sql
CREATE TABLE `video_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avid` bigint(20) NOT NULL COMMENT '视频AV号',
  `tag_id` int(11) NOT NULL COMMENT '标签ID',
  `tag_name` varchar(64) NOT NULL COMMENT '标签名称',
  `tag_type` tinyint(4) DEFAULT '1' COMMENT '标签类型: 1-分类标签 2-内容标签',
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_avid` (`avid`),
  KEY `idx_tag_id` (`tag_id`),
  KEY `idx_tag_name` (`tag_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='视频标签表';
```

#### 3.1.3 用户行为表 (`user_behavior`)
```sql
CREATE TABLE `user_behavior` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `mid` bigint(20) NOT NULL COMMENT '用户MID',
  `avid` bigint(20) NOT NULL COMMENT '视频AV号',
  `behavior_type` tinyint(4) NOT NULL COMMENT '行为类型: 1-播放 2-点赞 3-收藏 4-分享 5-关注',
  `duration` int(11) DEFAULT NULL COMMENT '观看时长(秒)',
  `finish_rate` decimal(5,2) DEFAULT NULL COMMENT '完播率',
  `ctime` bigint(20) NOT NULL COMMENT '行为时间戳',
  PRIMARY KEY (`id`),
  KEY `idx_mid_type` (`mid`, `behavior_type`),
  KEY `idx_avid` (`avid`),
  KEY `idx_ctime` (`ctime`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户行为表';
```

#### 3.1.4 用户关注表 (`user_follow`)
```sql
CREATE TABLE `user_follow` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `mid` bigint(20) NOT NULL COMMENT '用户MID',
  `up_mid` bigint(20) NOT NULL COMMENT 'UP主MID',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态: 1-关注 0-取消关注',
  `ctime` bigint(20) NOT NULL COMMENT '关注时间戳',
  `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_mid_up` (`mid`, `up_mid`),
  KEY `idx_up_mid` (`up_mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户关注表';
```

#### 3.1.5 用户黑名单表 (`user_blacklist`)
```sql
CREATE TABLE `user_blacklist` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `mid` bigint(20) NOT NULL COMMENT '用户MID',
  `up_mid` bigint(20) NOT NULL COMMENT 'UP主MID',
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_mid_up` (`mid`, `up_mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户黑名单表';
```

### 3.2 Redis 数据结构

#### 3.2.1 用户画像缓存
```
Key: user:profile:{mid}
Type: Hash
TTL: 3600 (1小时)
Fields:
  - zones: 兴趣分区（JSON）{"动画":0.8, "音乐":0.6}
  - tags: 兴趣标签（JSON）{"MMD":0.9, "VOCALOID":0.7}
  - pref_ups: 偏好UP主（JSON）{123456:1234567890, 789012:1234567891}
  - last_update: 最后更新时间戳
```

#### 3.2.2 用户实时行为（点赞）
```
Key: user:action:{mid}:like:{date}
Type: ZSet
Score: 时间戳
Member: avid
TTL: 604800 (7天)
示例: ZADD user:action:1001:like:20250108 1736294400 100001
```

#### 3.2.3 用户实时行为（正反馈）
```
Key: user:action:{mid}:pos:{date}
Type: ZSet
Score: 时间戳
Member: avid
说明: 观看时长>=15秒 或 完播率>=95%
```

#### 3.2.4 用户实时行为（负反馈）
```
Key: user:action:{mid}:neg:{date}
Type: ZSet
Score: 时间戳
Member: avid
说明: 观看时长<5秒 或 快速划过
```

#### 3.2.5 召回索引 - 热门视频
```
Key: recall:hot:default
Type: ZSet
Score: 热度分数（综合播放、点赞、时效性）
Member: avid
更新频率: 每小时
示例: ZADD recall:hot:default 95.6 100001 94.2 100002
```

#### 3.2.6 召回索引 - I2I 相似视频
```
Key: recall:i2i:{avid}
Type: ZSet
Score: 相似度分数
Member: similar_avid
示例: ZADD recall:i2i:100001 0.85 100002 0.78 100003
```

#### 3.2.7 召回索引 - 标签热门视频
```
Key: recall:tag:{tag_id}
Type: ZSet
Score: 热度分数
Member: avid
示例: ZADD recall:tag:1 95.0 100001 92.5 100002
```

#### 3.2.8 召回索引 - UP主视频
```
Key: recall:up:{up_mid}
Type: ZSet
Score: 发布时间戳（或热度）
Member: avid
示例: ZADD recall:up:123456 1736294400 100001
```

#### 3.2.9 召回索引 - 精选视频
```
Key: recall:selection
Type: List
Member: avid（State=5的视频）
更新频率: 实时
```

#### 3.2.10 布隆过滤器（去重）
```
Key: bloomfilter:{mid}:{date}
Type: Bloom Filter
说明: 记录用户观看过的视频AVID
TTL: 2592000 (30天)
```

#### 3.2.11 推荐结果缓存
```
Key: recommend:result:{mid}:{page}
Type: String (JSON)
TTL: 300 (5分钟)
说明: 缓存推荐结果，避免短时间重复计算
```

---

## 四、核心业务逻辑（严格按照主项目）

### 4.1 推荐主流程

#### 流程伪代码（基于主项目 `recsys.go`）
```go
func (s *Service) Recommend(ctx context.Context, req *RecommendRequest) (*RecommendResponse, error) {
    // 1. 加载用户画像
    userProfile, err := s.dao.LoadUserProfile(ctx, req.MID)
    if err != nil {
        return nil, err
    }
    
    // 2. 加载用户关注和黑名单
    s.dao.GetUserFollow(ctx, req.MID, userProfile)
    s.dao.GetUserBlack(ctx, req.MID, userProfile)
    
    // 3. 调用召回服务（多路召回）
    recallRequest := s.buildRecallRequest(req, userProfile)
    recallResponse, err := s.recallClient.Recall(ctx, recallRequest)
    if err != nil || len(recallResponse.List) == 0 {
        // 降级召回（放宽过滤条件）
        recallResponse, err = s.downGradeRecall(ctx, recallRequest)
    }
    
    response := &RecommendResponse{
        List: transformRecallToRecommend(recallResponse),
    }
    
    // 4. 初步过滤（精确去重 + 黑名单）
    s.filterManager.PreFilter(req, response, userProfile)
    
    // 5. 排序（XGBoost 模型）
    err = s.rankModelManager.DoRank(req, response, userProfile)
    if err != nil {
        // 降级为规则排序
        s.rankManager.RuleBasedRank(req, response, userProfile)
    }
    
    // 6. 后处理（布隆过滤 + 时长过滤 + 打散）
    s.postProcessor.Process(ctx, req, response, userProfile)
    
    // 7. 分页返回
    if len(response.List) > req.Limit {
        response.List = response.List[:req.Limit]
    }
    
    // 8. 记录推荐结果（用于去重）
    s.dao.StoreRecommendResult(ctx, req.MID, response)
    
    return response, nil
}
```

### 4.2 召回策略详细设计

#### 4.2.1 热门召回 (HotRecall)
**原理**: 全局热门视频，适合冷启动用户
```go
type HotRecallStrategy struct{}

func (s *HotRecallStrategy) Recall(ctx context.Context, req *RecallRequest) ([]*RecallItem, error) {
    // 从 Redis 获取热门视频
    key := "recall:hot:default"
    avids, scores := s.redis.ZRevRangeWithScores(ctx, key, 0, 200)
    
    // 应用布隆过滤器
    if req.EnableBloomFilter {
        avids = s.bloomFilter.Filter(req.MID, avids)
    }
    
    return s.buildRecallItems(avids, scores, "HotRecall"), nil
}
```

**召回数量**: 200个
**优先级**: Low (10)

#### 4.2.2 精选召回 (SelectionRecall)
**原理**: 运营精选视频（State=5）
```go
func (s *SelectionRecallStrategy) Recall(ctx context.Context, req *RecallRequest) ([]*RecallItem, error) {
    key := "recall:selection"
    avids := s.redis.LRange(ctx, key, 0, 100)
    
    if req.EnableBloomFilter {
        avids = s.bloomFilter.Filter(req.MID, avids)
    }
    
    return s.buildRecallItems(avids, nil, "SelectionRecall"), nil
}
```

**召回数量**: 100个
**优先级**: VeryHigh (10000)

#### 4.2.3 点赞I2I召回 (LikeI2IRecall)
**原理**: 基于用户点赞视频，通过I2I协同过滤召回相似视频
```go
func (s *LikeI2IRecallStrategy) Recall(ctx context.Context, req *RecallRequest) ([]*RecallItem, error) {
    // 1. 获取用户最近点赞的视频（Top 10）
    likeVideos := s.getUserLikeVideos(ctx, req.MID, req.Date, 10)
    
    results := make([]*RecallItem, 0)
    
    // 2. 对每个点赞视频，召回相似视频
    for _, avid := range likeVideos {
        key := fmt.Sprintf("recall:i2i:%d", avid)
        similarVideos, scores := s.redis.ZRevRangeWithScores(ctx, key, 0, 40)
        
        if req.EnableBloomFilter {
            similarVideos = s.bloomFilter.Filter(req.MID, similarVideos)
        }
        
        items := s.buildRecallItems(similarVideos, scores, "LikeI2IRecall")
        for _, item := range items {
            item.SourceAVID = avid // 记录来源视频
        }
        results = append(results, items...)
    }
    
    return results, nil
}
```

**召回数量**: Top 10 点赞视频 × 40 = 400个
**优先级**: VeryHigh (10000)

#### 4.2.4 标签召回 (TagRecall)
**原理**: 基于用户兴趣标签，召回对应标签的热门视频
```go
func (s *TagRecallStrategy) Recall(ctx context.Context, req *RecallRequest, userProfile *UserProfile) ([]*RecallItem, error) {
    results := make([]*RecallItem, 0)
    
    // 1. 用户点赞标签（实时数据，Top 10）
    likeTagIDs := s.extractTopNTags(userProfile.LikeTagIDs, 10)
    for tagID := range likeTagIDs {
        key := fmt.Sprintf("recall:tag:%d", tagID)
        avids, scores := s.redis.ZRevRangeWithScores(ctx, key, 0, 20)
        
        if req.EnableBloomFilter {
            avids = s.bloomFilter.Filter(req.MID, avids)
        }
        
        items := s.buildRecallItems(avids, scores, "LikeTagRecall")
        results = append(results, items...)
    }
    
    // 2. 用户画像标签（历史累积，Top 10）
    for tag, weight := range userProfile.Tags {
        if weight < 0.3 {
            continue // 过滤低权重标签
        }
        key := fmt.Sprintf("recall:tag:%s", tag)
        avids, scores := s.redis.ZRevRangeWithScores(ctx, key, 0, 20)
        
        if req.EnableBloomFilter {
            avids = s.bloomFilter.Filter(req.MID, avids)
        }
        
        items := s.buildRecallItems(avids, scores, "UserProfileTagRecall")
        results = append(results, items...)
    }
    
    return results, nil
}
```

**召回数量**: 10个标签 × 20 = 200个
**优先级**: High (1000)

#### 4.2.5 关注召回 (FollowRecall)
**原理**: 推荐用户关注的UP主的最新视频
```go
func (s *FollowRecallStrategy) Recall(ctx context.Context, req *RecallRequest, userProfile *UserProfile) ([]*RecallItem, error) {
    results := make([]*RecallItem, 0)
    
    // 获取用户最近关注的UP主（Top 10）
    followUps := s.extractTopNFollows(userProfile.FollowUps, 10)
    
    for upMID := range followUps {
        key := fmt.Sprintf("recall:up:%d", upMID)
        avids, scores := s.redis.ZRevRangeWithScores(ctx, key, 0, 40)
        
        if req.EnableBloomFilter {
            avids = s.bloomFilter.Filter(req.MID, avids)
        }
        
        items := s.buildRecallItems(avids, scores, "FollowRecall")
        for _, item := range items {
            item.SourceUPMID = upMID // 记录来源UP主
        }
        results = append(results, items...)
    }
    
    return results, nil
}
```

**召回数量**: 10个UP主 × 40 = 400个
**优先级**: High (1000)

#### 4.2.6 召回策略汇总

| 召回策略 | 数据来源 | 召回数量 | 优先级 | 适用场景 |
|---------|---------|---------|--------|---------|
| HotRecall | 全局热门 | 200 | Low | 冷启动用户、兜底 |
| SelectionRecall | 运营精选 | 100 | VeryHigh | 精品内容保证 |
| LikeI2IRecall | 用户点赞+I2I | 400 | VeryHigh | 强个性化信号 |
| LikeTagRecall | 点赞视频标签 | 200 | High | 内容相似性 |
| LikeUPRecall | 点赞视频UP主 | 400 | VeryHigh | 创作者偏好 |
| PosTagRecall | 正反馈标签 | 300 | High | 隐式兴趣捕捉 |
| FollowRecall | 关注UP主 | 400 | High | 实时性强 |
| UserProfileTagRecall | 用户画像标签 | 200 | Mid | 长期兴趣 |
| RandomRecall | 随机+新视频 | 100 | Low | 探索推荐 |

**总召回量**: ~2000-2500个候选视频

### 4.3 排序模型设计

#### 4.3.1 特征工程（65个特征 - 与 train_v13_final.py 完全对应）

**特征分类**:

1. **召回特征**（10个）- One-Hot 编码
```go
recall-HotRecall
recall-SelectionRecall
recall-LikeI2IRecall
recall-LikeTagRecall
recall-LikeUPRecall
recall-PosI2IRecall
recall-PosTagRecall
recall-UserProfileBili
recall-FollowRecall
recall-RandomRecall
```

2. **视频状态特征**（5个）- One-Hot 编码
```go
state-bucket-1  // State=1 (正常)
state-bucket-3  // State=3 (回查可放出)
state-bucket-4  // State=4 (优质)
state-bucket-5  // State=5 (精选)
```

3. **分区特征**（35个）- One-Hot 编码
```go
zone-bucket-20, zone-bucket-21, zone-bucket-22, ...
// B站主要分区: 动画、番剧、国创、音乐、舞蹈、游戏等
```

4. **视频统计特征**（全站数据，6个）
```go
play_hive        // 全站播放量（对数归一化）
likes_hive       // 全站点赞数（对数归一化）
fav_hive         // 全站收藏数（对数归一化）
reply_hive       // 全站评论数（对数归一化）
share_hive       // 全站分享数（对数归一化）
coin_hive        // 全站投币数（对数归一化）
```

5. **视频统计特征**（月度数据，5个）
```go
play_month         // 近30天播放量
likes_month        // 近30天点赞数
reply_month        // 近30天评论数
share_month        // 近30天分享数
play_month_finish  // 近30天完播量
```

6. **用户-视频交叉特征**（4个）
```go
has_tag_count      // 是否有标签匹配 (0/1)
contains_tag_count // 匹配标签数量 (0-N)
```

**特征构建代码**（`service/rank/feature.go`）:
```go
func BuildFeatureV13(record *RecommendRecord, userProfile *UserProfile) []float64 {
    features := make([]float64, 65)
    featureIdx := 0
    
    // 1. 分区特征 (35个 One-Hot)
    zoneID := record.ZoneID
    zoneFeatures := makeZoneBuckets(zoneID, 35)
    copy(features[featureIdx:], zoneFeatures)
    featureIdx += 35
    
    // 2. 召回特征 (10个 One-Hot)
    recallTypes := strings.Split(record.RecallTypes, "|")
    recallFeatures := makeRecallFeatures(recallTypes)
    copy(features[featureIdx:], recallFeatures)
    featureIdx += 10
    
    // 3. 状态特征 (5个 One-Hot)
    stateFeatures := makeStateBuckets(record.State, 5)
    copy(features[featureIdx:], stateFeatures)
    featureIdx += 5
    
    // 4. 全站统计特征 (6个)
    features[featureIdx] = math.Log10(record.PlayHive + 1) / math.Log10(1000000)
    features[featureIdx+1] = math.Log10(record.LikesHive + 1) / math.Log10(100000)
    features[featureIdx+2] = math.Log10(record.FavHive + 1) / math.Log10(50000)
    features[featureIdx+3] = math.Log10(record.ReplyHive + 1) / math.Log10(10000)
    features[featureIdx+4] = math.Log10(record.ShareHive + 1) / math.Log10(5000)
    features[featureIdx+5] = math.Log10(record.CoinHive + 1) / math.Log10(20000)
    featureIdx += 6
    
    // 5. 月度统计特征 (5个)
    features[featureIdx] = math.Log10(record.PlayMonth + 1) / math.Log10(100000)
    features[featureIdx+1] = math.Log10(record.LikesMonth + 1) / math.Log10(5000)
    features[featureIdx+2] = math.Log10(record.ReplyMonth + 1) / math.Log10(2000)
    features[featureIdx+3] = math.Log10(record.ShareMonth + 1) / math.Log10(1000)
    features[featureIdx+4] = math.Log10(record.PlayMonthFinish + 1) / math.Log10(50000)
    featureIdx += 5
    
    // 6. 交叉特征 (4个)
    matchTagCount := countMatchTags(record.TagIDs, userProfile.Tags)
    features[featureIdx] = float64(matchTagCount > 0) // has_tag_count
    features[featureIdx+1] = float64(matchTagCount)   // contains_tag_count
    featureIdx += 2
    
    return features
}
```

#### 4.3.2 XGBoost 模型加载（TreeLite Protobuf 格式）

**模型配置** (`models/0.0.13/config.json`):
```json
{
  "version": "0.0.13",
  "num_features": 65,
  "num_trees": 150,
  "format": "treelite_protobuf"
}
```

**模型加载代码** (`service/rank/model.go`):
```go
import (
    xgb "go-common/library/ml/xgboost/treelite"
)

type RankModelManager struct {
    model *xgb.Model
}

func NewRankModelManager(modelDir string) (*RankModelManager, error) {
    // 加载 TreeLite Protobuf 模型
    modelPath := filepath.Join(modelDir, "model.proto")
    model, err := xgb.LoadModel(modelPath)
    if err != nil {
        return nil, fmt.Errorf("load model failed: %v", err)
    }
    
    return &RankModelManager{model: model}, nil
}

func (m *RankModelManager) DoRank(req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error {
    // 1. 构建特征
    for _, record := range response.List {
        features := BuildFeatureV13(record, userProfile)
        
        // 2. 模型预测
        score := m.model.PredictSingle(features)
        record.Score = score
    }
    
    // 3. 按分数排序
    sort.Slice(response.List, func(i, j int) bool {
        return response.List[i].Score > response.List[j].Score
    })
    
    return nil
}
```

### 4.4 过滤器设计

#### 4.4.1 过滤器链
```go
type FilterChain struct {
    filters []Filter
}

type Filter interface {
    DoFilter(req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error
}
```

#### 4.4.2 精确去重过滤器 (DefaultFilter)
```go
type DefaultFilterNode struct{}

func (f *DefaultFilterNode) DoFilter(req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error {
    seen := make(map[int64]bool)
    filtered := make([]*RecommendRecord, 0)
    
    for _, record := range response.List {
        if !seen[record.AVID] {
            seen[record.AVID] = true
            filtered = append(filtered, record)
        }
    }
    
    response.List = filtered
    return nil
}
```

#### 4.4.3 布隆过滤器 (BloomFilter)
```go
type BloomFilterNode struct {
    dao *dao.Dao
}

func (f *BloomFilterNode) DoFilter(req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error {
    // 降级状态下不应用布隆过滤
    if response.Downgraded {
        return nil
    }
    
    filtered := make([]*RecommendRecord, 0)
    
    for _, record := range response.List {
        // 检查用户是否看过该视频
        existed := f.dao.BloomFilter.MightContain(userProfile.MID, record.AVID)
        if !existed {
            filtered = append(filtered, record)
        }
    }
    
    response.List = filtered
    return nil
}
```

#### 4.4.4 黑名单过滤器 (BlackFilter)
```go
type BlackFilterNode struct{}

func (f *BlackFilterNode) DoFilter(req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error {
    filtered := make([]*RecommendRecord, 0)
    
    for _, record := range response.List {
        // 检查UP主是否在黑名单中
        if _, blacklisted := userProfile.BlackUps[record.UPMID]; !blacklisted {
            filtered = append(filtered, record)
        }
    }
    
    response.List = filtered
    return nil
}
```

#### 4.4.5 时长过滤器 (DurationFilter)
```go
type DurationFilterNode struct{}

func (f *DurationFilterNode) DoFilter(req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error {
    filtered := make([]*RecommendRecord, 0)
    
    for _, record := range response.List {
        // B站主站视频时长控制：1分钟-60分钟
        if record.Duration >= 60 && record.Duration <= 3600 {
            filtered = append(filtered, record)
        }
    }
    
    response.List = filtered
    return nil
}
```

### 4.5 后处理策略

#### 4.5.1 打散策略 (Scatter)
**目的**: 避免连续推荐同一UP主或同一标签的视频

```go
type ScatterPostProcessor struct{}

func (p *ScatterPostProcessor) Process(ctx context.Context, req *RecommendRequest, response *RecommendResponse, userProfile *UserProfile) error {
    if len(response.List) <= 3 {
        return nil // 结果太少，不需要打散
    }
    
    scattered := make([]*RecommendRecord, 0)
    upMIDLastIdx := make(map[int64]int)
    tagLastIdx := make(map[string]int)
    
    for i, record := range response.List {
        // 检查UP主打散
        if lastIdx, exists := upMIDLastIdx[record.UPMID]; exists {
            if i-lastIdx < 3 {
                // 距离太近，跳过或延后
                continue
            }
        }
        
        // 检查标签打散
        shouldScatter := false
        for _, tag := range record.Tags {
            if lastIdx, exists := tagLastIdx[tag]; exists {
                if i-lastIdx < 5 {
                    shouldScatter = true
                    break
                }
            }
        }
        
        if !shouldScatter {
            scattered = append(scattered, record)
            upMIDLastIdx[record.UPMID] = len(scattered) - 1
            for _, tag := range record.Tags {
                tagLastIdx[tag] = len(scattered) - 1
            }
        }
    }
    
    response.List = scattered
    return nil
}
```

---

## 五、API 设计

### 5.1 HTTP API（通过 creative-api 网关）

#### 5.1.1 获取推荐列表
```http
GET /api/creative/v1/recommend/list

Request Query Parameters:
- mid: int64 (必需) - 用户ID
- limit: int (可选，默认20) - 返回数量
- page: int (可选，默认1) - 页码

Response:
{
  "code": 0,
  "message": "success",
  "data": {
    "list": [
      {
        "avid": 100001,
        "title": "【MMD】初音未来",
        "cover": "http://i0.hdslb.com/bfs/archive/...",
        "duration": 180,
        "pub_time": 1736294400,
        "zone_id": 20,
        "zone_name": "动画",
        "up_mid": 123456,
        "up_name": "某UP主",
        "play": 10000,
        "like": 500,
        "score": 0.85,
        "reason": "根据你喜欢的标签推荐"
      }
    ],
    "total": 100,
    "has_more": true
  }
}
```

### 5.2 gRPC API

#### 5.2.1 推荐服务 Proto 定义
```protobuf
syntax = "proto3";

package recommend.v1;

service Recommend {
  rpc GetRecommendList(RecommendRequest) returns (RecommendResponse);
}

message RecommendRequest {
  int64 mid = 1;           // 用户ID
  int32 limit = 2;         // 返回数量
  int32 page = 3;          // 页码
  bool debug = 4;          // 调试模式
}

message RecommendResponse {
  repeated RecommendItem list = 1;
  int32 total = 2;
  bool has_more = 3;
  map<string, string> debug_info = 4;
}

message RecommendItem {
  int64 avid = 1;
  string title = 2;
  string cover = 3;
  int32 duration = 4;
  int64 pub_time = 5;
  int32 zone_id = 6;
  int64 up_mid = 7;
  int64 play = 8;
  int64 like = 9;
  double score = 10;
  string reason = 11;
}
```

#### 5.2.2 召回服务 Proto 定义
```protobuf
syntax = "proto3";

package recall.v1;

service Recall {
  rpc Recall(RecallRequest) returns (RecallResponse);
  rpc VideoIndex(VideoIndexRequest) returns (VideoIndexResponse);
}

message RecallRequest {
  int64 mid = 1;
  string buvid = 2;
  int32 total_limit = 3;
  repeated RecallInfo infos = 4;
}

message RecallInfo {
  string name = 1;           // 召回策略名称
  string tag = 2;            // Redis key
  int32 limit = 3;           // 召回数量
  string filter = 4;         // 过滤器类型
  int32 priority = 5;        // 优先级
  string scorer = 6;         // 打分器
}

message RecallResponse {
  repeated RecallItem list = 1;
  int32 total = 2;
}

message RecallItem {
  int64 avid = 1;
  double score = 2;
  string recall_type = 3;
  string recall_tag = 4;
  map<string, string> extra = 5;
}

message VideoIndexRequest {
  repeated int64 avids = 1;
}

message VideoIndexResponse {
  repeated VideoIndex list = 1;
}

message VideoIndex {
  int64 avid = 1;
  BasicInfo basic_info = 2;
}

message BasicInfo {
  int64 mid = 1;
  string title = 2;
  int32 zone_id = 3;
  repeated Tag tags = 4;
}

message Tag {
  int64 tag_id = 1;
  string tag_name = 2;
}
```

---

## 六、配置文件

### 6.1 recommend-rpc 配置
```yaml
Name: recommend.rpc
Mode: dev
ListenOn: 127.0.0.1:9005

# etcd 服务注册
Etcd:
  Hosts:
    - 127.0.0.1:23790
  Key: recommend.rpc

# Prometheus 监控
Prometheus:
  Host: 127.0.0.1
  Port: 9095
  Path: /metrics

# MySQL 配置
MySQL:
  DataSource: root:root123456@tcp(127.0.0.1:33060)/mybilibili?charset=utf8mb4&parseTime=true&loc=Local

# Redis 配置
Redis:
  Host: 127.0.0.1:63790
  Pass: redis123456
  Type: node

# 依赖服务
RecallRpc:
  Etcd:
    Hosts:
      - 127.0.0.1:23790
    Key: recall.rpc
  Timeout: 5000

VideoRpc:
  Etcd:
    Hosts:
      - 127.0.0.1:23790
    Key: video.rpc
  Timeout: 5000

# 模型配置
RankModel:
  ModelDir: ./models/0.0.13
  ModelVersion: 0.0.13

# 业务配置
Business:
  # 召回配置
  RecallLimit: 500           # 总召回数量
  RecallTimeout: 3000        # 召回超时时间(ms)
  
  # 排序配置
  RankEnable: true          # 是否启用模型排序
  RankFallback: true        # 排序失败是否降级
  
  # 过滤配置
  BloomFilterEnable: true   # 是否启用布隆过滤
  DurationMin: 60           # 最短时长(秒)
  DurationMax: 3600         # 最长时长(秒)
  
  # 后处理配置
  ScatterUPMinDistance: 3   # UP主打散最小距离
  ScatterTagMinDistance: 5  # 标签打散最小距离
  
  # 缓存配置
  CacheTTL: 300            # 推荐结果缓存时长(秒)
```

### 6.2 recall-rpc 配置
```yaml
Name: recall.rpc
Mode: dev
ListenOn: 127.0.0.1:9006

# etcd 服务注册
Etcd:
  Hosts:
    - 127.0.0.1:23790
  Key: recall.rpc

# Prometheus 监控
Prometheus:
  Host: 127.0.0.1
  Port: 9096
  Path: /metrics

# Redis 配置
Redis:
  Host: 127.0.0.1:63790
  Pass: redis123456
  Type: node

# MySQL 配置（视频索引）
MySQL:
  DataSource: root:root123456@tcp(127.0.0.1:33060)/mybilibili?charset=utf8mb4&parseTime=true&loc=Local

# 召回策略配置
RecallStrategies:
  - Name: HotRecall
    Enable: true
    Limit: 200
    Priority: 10
    
  - Name: SelectionRecall
    Enable: true
    Limit: 100
    Priority: 10000
    
  - Name: LikeI2IRecall
    Enable: true
    TopN: 10
    LimitPerItem: 40
    Priority: 10000
    
  - Name: TagRecall
    Enable: true
    TopN: 10
    LimitPerTag: 20
    Priority: 1000
    
  - Name: FollowRecall
    Enable: true
    TopN: 10
    LimitPerUP: 40
    Priority: 1000

# 布隆过滤器配置
BloomFilter:
  ExpectedInsertions: 10000
  FalsePositiveRate: 0.01
```

---

## 七、开发计划

### 7.1 Phase 1: 基础框架搭建（2-3天）
- [ ] 创建 `recommend-rpc` 服务骨架
- [ ] 创建 `recall-rpc` 服务骨架
- [ ] 定义 Proto 文件并生成代码
- [ ] 实现基础的数据访问层（MySQL + Redis）
- [ ] 实现服务注册与发现

### 7.2 Phase 2: 召回系统实现（3-4天）
- [ ] 实现热门召回策略
- [ ] 实现精选召回策略
- [ ] 实现I2I召回策略
- [ ] 实现标签召回策略
- [ ] 实现关注召回策略
- [ ] 实现用户画像召回策略
- [ ] 实现召回结果合并与去重
- [ ] 实现布隆过滤器

### 7.3 Phase 3: 排序系统实现（2-3天）
- [ ] 实现特征工程模块（65个特征）
- [ ] 集成 TreeLite 模型加载
- [ ] 实现 XGBoost 预测逻辑
- [ ] 实现规则排序（降级方案）
- [ ] 模型测试与验证

### 7.4 Phase 4: 过滤与后处理（2天）
- [ ] 实现过滤器链
- [ ] 实现各类过滤器（去重、黑名单、时长）
- [ ] 实现打散策略
- [ ] 实现推荐理由生成

### 7.5 Phase 5: 用户画像系统（2天）
- [ ] 实现用户画像加载
- [ ] 实现实时行为数据加载
- [ ] 实现画像更新逻辑
- [ ] 实现关注/黑名单管理

### 7.6 Phase 6: API 接口开发（1-2天）
- [ ] 在 creative-api 中添加推荐接口
- [ ] 实现分页逻辑
- [ ] 实现缓存逻辑
- [ ] 实现调试模式

### 7.7 Phase 7: 测试与优化（2-3天）
- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能测试
- [ ] 推荐效果测试
- [ ] 监控指标完善

**总预计时间**: 14-19天

---

## 八、监控指标

### 8.1 核心指标

#### 推荐服务指标
```promql
# QPS
rate(rpc_server_requests_code_total{service="recommend-rpc"}[5m])

# 平均响应时间
rate(rpc_server_requests_duration_ms_sum{service="recommend-rpc"}[5m]) / 
rate(rpc_server_requests_duration_ms_count{service="recommend-rpc"}[5m])

# 错误率
sum(rate(rpc_server_requests_code_total{service="recommend-rpc",code!="0"}[5m])) / 
sum(rate(rpc_server_requests_code_total{service="recommend-rpc"}[5m]))

# 召回数量
recommend_recall_count

# 排序后数量
recommend_rank_count

# 最终返回数量
recommend_result_count
```

#### 召回服务指标
```promql
# 各召回策略召回数量
recall_strategy_count{strategy="HotRecall"}
recall_strategy_count{strategy="LikeI2IRecall"}

# 召回耗时
recall_strategy_duration_ms{strategy="HotRecall"}
```

### 8.2 业务指标

- **推荐点击率 (CTR)**: 推荐视频被点击次数 / 推荐曝光次数
- **推荐完播率**: 推荐视频完播次数 / 推荐播放次数
- **推荐点赞率**: 推荐视频点赞次数 / 推荐播放次数
- **召回覆盖率**: 非重复推荐视频数 / 总视频数
- **用户满意度**: 用户负反馈率（快速划过、不感兴趣）

---

## 九、风险与挑战

### 9.1 技术风险

1. **模型兼容性问题**
   - **风险**: TreeLite Protobuf 格式在 Go 中加载失败
   - **缓解**: 提供规则排序降级方案，优先使用 JSON 格式模型

2. **性能瓶颈**
   - **风险**: 多路召回并发导致 Redis 压力过大
   - **缓解**: 实现召回结果缓存、限流、降级策略

3. **数据稀疏性**
   - **风险**: 新用户/新视频数据不足，推荐效果差
   - **缓解**: 热门召回兜底、AB测试

### 9.2 业务风险

1. **推荐效果不佳**
   - **风险**: 用户不点击推荐内容
   - **缓解**: 持续优化召回策略、模型迭代、AB测试

2. **内容质量问题**
   - **风险**: 推荐低质量视频
   - **缓解**: 强化精选召回权重、增加质量过滤规则

---

## 十、总结

本设计方案严格基于 Bilibili 主项目的 `recsys` 和 `recsys-recall` 模块，实现了完整的三阶段推荐系统：

1. **召回阶段**: 9种召回策略，从海量视频中快速筛选出2000+候选集
2. **排序阶段**: XGBoost 模型（65个特征），精准预测点击率并排序
3. **过滤阶段**: 多重过滤器 + 打散策略，保证推荐质量和多样性

核心优势：
- ✅ **架构清晰**: 召回、排序、过滤职责分离，易于维护和优化
- ✅ **扩展性强**: 支持灵活添加新的召回策略和过滤规则
- ✅ **性能优秀**: 并行召回、缓存机制、降级策略保证高可用
- ✅ **模型兼容**: 完全适配 `train_v13_final.py` 导出的模型

下一步：开始实现 Phase 1（基础框架搭建）。