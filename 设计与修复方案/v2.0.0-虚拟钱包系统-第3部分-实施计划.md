# MyBilibili 虚拟钱包系统设计方案 v2.0.0（第3部分）

## 八、分步实现计划（可分步，不简化）

### 阶段一：基础架构搭建（第1周）

**目标**：完成项目结构、数据库、基础配置

#### 1.1 创建项目结构
```bash
# 创建目录
mkdir -p app/wallet/cmd/api
mkdir -p app/wallet/cmd/rpc
mkdir -p app/wallet/model

# 初始化proto
cd app/wallet/cmd/rpc
touch wallet.proto

# 初始化API
cd app/wallet/cmd/api/desc
touch wallet.api
```

#### 1.2 数据库初始化
```sql
-- deploy/sql/010_wallet_schema.sql

-- 用户钱包表（10张）
CREATE TABLE `user_wallet_0` (...);
CREATE TABLE `user_wallet_1` (...);
...
CREATE TABLE `user_wallet_9` (...);

-- 流水记录表（10张）
CREATE TABLE `coin_stream_record_0` (...);
...

-- 兑换记录表
CREATE TABLE `coin_exchange_record` (...);
```

#### 1.3 生成Model代码
```bash
# 生成user_wallet model
goctl model mysql datasource \
  -url="root:root123456@tcp(127.0.0.1:33060)/mybilibili" \
  -table="user_wallet_0" \
  -dir=./app/wallet/model \
  --style go_zero \
  -c

# 手动修改支持分表逻辑
```

#### 1.4 配置文件模板
```yaml
# app/wallet/cmd/rpc/etc/wallet.yaml
Name: wallet.rpc
ListenOn: 127.0.0.1:9004

Etcd:
  Hosts:
    - 127.0.0.1:23790
  Key: wallet.rpc

Mysql:
  DataSource: root:root123456@tcp(127.0.0.1:33060)/mybilibili?charset=utf8mb4&parseTime=true

CacheRedis:
  - Host: 127.0.0.1:6379
    Type: node
```

---

### 阶段二：充值功能（第2周）

**目标**：完整实现充值流程（包括双重锁、事务、流水）

#### 2.1 实现充值RPC
- [ ] Protobuf定义（RechargeReq/Resp）
- [ ] 生成RPC代码（goctl rpc protoc）
- [ ] 实现RechargeLogic
  - [ ] 参数校验
  - [ ] TransactionID锁
  - [ ] 用户锁
  - [ ] 数据库事务
  - [ ] FOR UPDATE
  - [ ] UPDATE余额
  - [ ] INSERT流水
  - [ ] 删除缓存
  - [ ] 发布消息（可选）

#### 2.2 实现充值API
- [ ] API定义（wallet.api）
- [ ] 生成API代码
- [ ] 实现RechargeHandler/Logic
- [ ] 调用RPC服务

#### 2.3 单元测试
```go
// app/wallet/cmd/rpc/internal/logic/recharge_logic_test.go
func TestRechargeLogic_Recharge(t *testing.T) {
    // 测试用例1：正常充值
    // 测试用例2：重复提交
    // 测试用例3：并发充值
}
```

#### 2.4 集成测试
```bash
# 测试命令
curl -X POST http://localhost:8004/api/wallet/v1/recharge \
  -H "Content-Type: application/json" \
  -d '{
    "uid": 1001,
    "coin_type": "gold",
    "coin_num": 100,
    "transaction_id": "tid_001",
    "platform": "android"
  }'
```

---

### 阶段三：消费功能（第3周）

**目标**：实现消费流程（重点：余额检查、防超支）

#### 3.1 实现消费RPC
- [ ] Protobuf定义
- [ ] 实现PayLogic
  - [ ] 余额检查⭐
  - [ ] 失败流水记录
  - [ ] 其他同充值

#### 3.2 实现消费API

#### 3.3 测试
```go
func TestPayLogic_Pay(t *testing.T) {
    // 测试用例1：正常消费
    // 测试用例2：余额不足
    // 测试用例3：并发消费（防超支）
}
```

---

### 阶段四：兑换功能（第4周）

**目标**：实现兑换流程（重点：原子性兑换、两条流水）

#### 4.1 实现兑换RPC
- [ ] Protobuf定义
- [ ] 实现ExchangeLogic
  - [ ] 原子UPDATE⭐
  - [ ] 两条流水
  - [ ] 兑换记录

#### 4.2 实现兑换API

#### 4.3 测试
```go
func TestExchangeLogic_Exchange(t *testing.T) {
    // 测试用例1：金瓜子兑换银瓜子
    // 测试用例2：银瓜子兑换金瓜子
    // 测试用例3：余额不足
}
```

---

### 阶段五：查询功能（第5周）

**目标**：实现余额查询、流水查询

#### 5.1 实现查询RPC
- [ ] GetDetail（余额）
- [ ] GetStreamList（流水）
- [ ] 缓存策略

#### 5.2 实现查询API

#### 5.3 测试

---

### 阶段六：高级功能（第6周）

**目标**：快照机制、消息队列、监控

#### 6.1 快照机制
```go
// 每日0点更新快照
func UpdateSnapshot(uid int64) {
    // 获取当前余额
    // 更新snapshot_time、snapshot_gold等字段
}
```

#### 6.2 Kafka消息发布
```go
func (l *RechargeLogic) publishWalletChange(uid int64, action string, ...) {
    msg := &WalletChangeMsg{
        Uid:      uid,
        Action:   action,
        CoinType: coinType,
        Number:   number,
        Balance:  balance,
    }
    l.svcCtx.Kafka.Send("wallet.change", msg)
}
```

#### 6.3 Prometheus监控
```go
// 监控指标
var (
    rechargeTotal     = prometheus.NewCounterVec(...)
    rechargeFailTotal = prometheus.NewCounterVec(...)
    rechargeDuration  = prometheus.NewHistogramVec(...)
)
```

---

## 九、测试方案

### 9.1 单元测试

**测试覆盖率目标**：>80%

```bash
# 运行测试
go test ./app/wallet/... -v

# 测试覆盖率
go test ./app/wallet/... -cover
```

### 9.2 并发测试

**测试场景**：
1. 同一用户并发充值（验证用户锁）
2. 同一TransactionID重复提交（验证TransactionID锁）
3. 同一用户并发消费（验证防超支）

```go
// 并发测试示例
func TestConcurrentPay(t *testing.T) {
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // 调用Pay接口
        }()
    }
    wg.Wait()
    
    // 验证最终余额正确
    // 验证没有超支
}
```

### 9.3 压力测试

```bash
# 使用wrk进行压力测试
wrk -t10 -c100 -d30s \
  --script=test/recharge.lua \
  http://localhost:8004/api/wallet/v1/recharge
```

### 9.4 对账测试

```go
// 验证快照机制
func TestReconciliation(t *testing.T) {
    // 昨日快照 + 今日充值 - 今日消费 + 今日兑换 = 今日余额
    yesterday := getSnapshot(uid)
    recharge := getTodayRecharge(uid)
    pay := getTodayPay(uid)
    exchange := getTodayExchange(uid)
    current := getCurrentBalance(uid)
    
    assert.Equal(t, yesterday + recharge - pay + exchange, current)
}
```

---

## 十、部署方案

### 10.1 Docker Compose部署（开发环境）

```yaml
# deploy/docker-compose.yml（添加wallet服务）

services:
  wallet-rpc:
    build:
      context: ..
      dockerfile: app/wallet/cmd/rpc/Dockerfile
    ports:
      - "9004:9004"
    depends_on:
      - mysql
      - redis
      - etcd
    environment:
      - MYSQL_DSN=root:root123456@tcp(mysql:3306)/mybilibili
      - REDIS_HOST=redis:6379
      - ETCD_HOSTS=etcd:2379
  
  wallet-api:
    build:
      context: ..
      dockerfile: app/wallet/cmd/api/Dockerfile
    ports:
      - "8004:8004"
    depends_on:
      - wallet-rpc
```

### 10.2 K8s部署（生产环境）

```yaml
# deploy/k8s/wallet-rpc-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wallet-rpc
spec:
  replicas: 3
  selector:
    matchLabels:
      app: wallet-rpc
  template:
    metadata:
      labels:
        app: wallet-rpc
    spec:
      containers:
      - name: wallet-rpc
        image: mybilibili/wallet-rpc:latest
        ports:
        - containerPort: 9004
        env:
        - name: MYSQL_DSN
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: dsn
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

---

## 十一、监控与告警

### 11.1 关键指标

```go
// 业务指标
- wallet_recharge_total{platform="ios"}      # 充值次数
- wallet_pay_total{result="success"}         # 消费次数
- wallet_pay_fail_total{reason="not_enough"} # 失败次数
- wallet_balance_snapshot{uid="1001"}        # 余额快照

// 性能指标
- wallet_recharge_duration_seconds           # 充值耗时
- wallet_lock_wait_seconds                   # 锁等待时间

// 系统指标
- wallet_db_connection_pool_size             # 数据库连接数
- wallet_redis_connection_pool_size          # Redis连接数
```

### 11.2 告警规则

```yaml
# prometheus/rules/wallet.yml
groups:
- name: wallet_alerts
  rules:
  # 余额不足错误率>10%
  - alert: HighCoinNotEnoughRate
    expr: rate(wallet_pay_fail_total{reason="not_enough"}[5m]) > 0.1
    for: 5m
    annotations:
      summary: "高余额不足错误率"
  
  # 充值失败率>5%
  - alert: HighRechargeFailRate
    expr: rate(wallet_recharge_fail_total[5m]) > 0.05
    for: 5m
    annotations:
      summary: "高充值失败率"
  
  # 锁等待时间>3s
  - alert: LongLockWait
    expr: wallet_lock_wait_seconds > 3
    for: 1m
    annotations:
      summary: "锁等待时间过长"
```

---

## 十二、性能优化

### 12.1 数据库优化

```sql
-- 索引优化
CREATE INDEX idx_uid ON user_wallet_X(uid);
CREATE INDEX idx_tid ON coin_stream_record_X(transaction_id);
CREATE INDEX idx_uid_optime ON coin_stream_record_X(uid, op_time);

-- 分表策略
-- user_wallet: 按uid取模分10张
-- coin_stream_record: 按transaction_id hash分10张
```

### 12.2 缓存策略

```go
// 1. 余额缓存（Memcache）
cacheKey := fmt.Sprintf("wallet:balance:%d", uid)
ttl := 86400 // 1天

// 2. 热点数据预热
func WarmUpCache(uids []int64) {
    for _, uid := range uids {
        detail, _ := walletModel.FindOne(uid)
        cache.Set(uid, detail, ttl)
    }
}

// 3. 缓存更新策略
// - 写操作：先更新DB，再删除缓存
// - 读操作：先查缓存，miss时查DB并回填
```

### 12.3 并发优化

```go
// 1. 批量查询优化
func BatchGetDetail(uids []int64) (map[int64]*WalletDetail, error) {
    // 使用IN查询，减少数据库往返
    query := "SELECT * FROM user_wallet_X WHERE uid IN (?)"
    // ...
}

// 2. 异步消息发布
go func() {
    kafka.Send("wallet.change", msg)
}()

// 3. 读写分离
// 查询走从库，写操作走主库
```

---

## 十三、FAQ与注意事项

### 13.1 为什么使用双重锁？

**TransactionID锁**：防止重复提交（幂等性）  
**用户锁**：防止并发修改余额（防超支）  

两者缺一不可，组合使用才能保证数据一致性。

### 13.2 为什么需要FOR UPDATE？

**Redis锁的局限**：网络抖动可能导致锁丢失  
**FOR UPDATE作用**：数据库层面的悲观锁，保证事务内数据强一致性  
**组合使用**：Redis锁快速失败，FOR UPDATE终极保障

### 13.3 为什么消费失败也要记录流水？

1. **问题排查**：用户投诉时可以查询失败原因
2. **数据分析**：分析失败率，优化产品设计
3. **监控告警**：监控异常流量

### 13.4 如何保证99.99%一致性？

1. **事务保证**：ACID特性
2. **双重锁**：防止并发问题
3. **完整流水**：每笔交易可追溯
4. **快照机制**：每日对账
5. **监控告警**：实时发现问题

### 13.5 iOS和Android为什么要分开？

**Apple政策要求**：iOS应用内的虚拟货币必须通过IAP购买  
**解决方案**：使用两个字段`gold`和`iap_gold`分别存储  
**平台判断**：根据platform参数选择对应字段

---

## 十四、交付标准

### 14.1 功能完整性

- [x] 充值功能（含双重锁、事务、流水）
- [x] 消费功能（含余额检查、防超支）
- [x] 兑换功能（含原子性、两条流水）
- [x] 查询功能（含缓存）
- [x] 流水查询
- [x] 快照机制（对账）

### 14.2 代码质量

- [x] 单元测试覆盖率>80%
- [x] 通过go vet检查
- [x] 通过golangci-lint检查
- [x] 代码注释完整

### 14.3 文档完整性

- [x] API文档
- [x] 部署文档
- [x] 运维文档
- [x] 设计文档（本文档）

### 14.4 性能指标

- [ ] 充值接口RT<100ms（P99）
- [ ] 消费接口RT<100ms（P99）
- [ ] 兑换接口RT<100ms（P99）
- [ ] 查询接口RT<50ms（P99）
- [ ] 支持并发1000 QPS

---

**总结：**

本设计方案严格按照bilibili主项目实现，完整保留了双币种账户体系、分布式事务保障、实时清算系统三大核心特性。采用go-zero微服务框架，分6个阶段逐步实现，确保每个阶段都有完整的功能和测试，不简化任何核心业务逻辑。

**下一步：**
1. Review本设计方案
2. 创建项目结构
3. 开始阶段一的实施
