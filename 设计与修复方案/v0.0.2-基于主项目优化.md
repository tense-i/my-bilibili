# MyBilibili 热门视频排行榜系统开发方案 v0.0.2
## 基于主项目 Bilibili 架构的优化设计

---

## 一、主项目 Bilibili 架构分析

### 1.1 主项目关键特点总结

通过分析主项目代码，我发现以下关键设计：

#### 1.1.1 项目结构
```
bilibili/
├── app/
│   ├── job/main/creative/          # 定时任务服务（热度计算）
│   │   ├── cmd/                    # 入口和配置
│   │   ├── dao/                    # 数据访问层
│   │   │   ├── academy/           # 学院数据（热度表）
│   │   │   ├── archive/           # 视频数据（RPC调用）
│   │   │   └── ...
│   │   ├── model/                  # 数据模型
│   │   └── service/                # 业务逻辑
│   │       └── academy.go         # 热度计算核心逻辑
│   │
│   └── admin/main/creative/        # 后台管理服务（HTTP API）
│       └── http/
│           └── academy_archive.go  # 热门视频管理接口
```

#### 1.1.2 技术栈
- **框架**：Kratos（B站自研微服务框架）
- **RPC**：gorpc（B站内部RPC，基于gRPC）
- **数据库**：go-common/library/database/sql（MySQL封装）
- **消息队列**：databus（Kafka封装）
- **日志**：go-common/library/log
- **链路追踪**：go-common/library/net/trace

#### 1.1.3 核心设计模式

**1. Service层设计**
```go
type Service struct {
    c   *conf.Config      // 配置
    arc *archive.Dao      // RPC客户端（调用视频服务）
    aca *academy.Dao      // 数据库DAO（热度表）
    wg  sync.WaitGroup    // 协程管理
}
```

**2. DAO层设计**
```go
// academy DAO：直连数据库
type Dao struct {
    c  *conf.Config
    db *sql.DB  // MySQL连接池
}

// archive DAO：RPC调用
type Dao struct {
    c   *conf.Config
    arc *archive.Service2  // Archive服务RPC客户端
    art *article.Service   // Article服务RPC客户端
}
```

**3. 热度计算流程**
```go
// 定时任务启动
if c.HotSwitch {
    go s.FlushHot(model.BusinessForArchive)  // 视频
    go s.FlushHot(model.BusinessForArticle)  // 专栏
}

// 循环计算
for {
    // 1. 游标分页查询
    arcs, _ := s.aca.Archives(c, id, bs, 30)
    
    // 2. 批量获取视频数据（RPC调用）
    stats, _ := s.arc.Stats(c, oids)
    arcs, _ := s.arc.Archives(c, oids)
    
    // 3. 计算热度值
    hots := s.computeHotByOIDs(c, oids, bs)
    
    // 4. 批量更新数据库
    s.aca.UPHotByAIDs(c, hots)
    
    // 5. 循环完成后休眠1小时
    if count == 0 {
        id = 0
        time.Sleep(time.Hour * 1)
    }
}
```

**4. 数据库批量更新**
```go
// 使用 CASE WHEN 批量更新
sql := "UPDATE academy_archive SET hot = CASE oid "
for oid, hot := range hots {
    sql += fmt.Sprintf("WHEN %d THEN %d ", oid, hot)
    oids = append(oids, oid)
}
sql += fmt.Sprintf("END, mtime=? WHERE oid IN (%s)", xstr.JoinInts(oids))
```

---

## 二、MyBilibili 架构设计（参考主项目）

### 2.1 核心设计思想

> **关键原则**：保持主项目的简洁架构，使用 go-zero 替代 Kratos，但保留核心设计模式

### 2.2 技术栈对比与选型

| 组件 | 主项目 Bilibili | MyBilibili | 说明 |
|-----|----------------|------------|------|
| **微服务框架** | Kratos | **go-zero** | 用户要求 |
| **RPC协议** | gorpc | **gRPC** | go-zero内置 |
| **数据库** | go-common/sql | **sqlx + go-zero model** | go-zero生态 |
| **消息队列** | databus | **go-queue（Kafka）** | go-zero生态 |
| **配置** | toml + remote config | **yaml** | go-zero标准 |
| **日志** | go-common/log | **logx** | go-zero内置 |
| **链路追踪** | go-common/trace | **jaeger** | go-zero支持 |
| **缓存** | 无（主项目不用） | **Redis** | 增强性能 |

### 2.3 项目目录结构

```
mybilibili/
├── api/                                    # HTTP API 网关（对外）
│   └── creative-api/                       # 创作中心API
│       ├── etc/
│       │   └── creative-api.yaml
│       ├── internal/
│       │   ├── config/
│       │   │   └── config.go
│       │   ├── handler/
│       │   │   └── academy/               # 热门视频相关接口
│       │   │       ├── addarchandler.go   # 添加视频到热门池
│       │   │       ├── listarchandler.go  # 查询热门列表
│       │   │       └── removearchandler.go
│       │   ├── logic/
│       │   │   └── academy/
│       │   ├── svc/
│       │   │   └── servicecontext.go
│       │   └── types/
│       │       └── types.go
│       ├── creative.api
│       └── creative.go
│
├── service/                                # RPC 服务层
│   ├── video/                             # 视频服务（依赖）
│   │   └── rpc/
│   │       ├── etc/
│   │       │   └── video.yaml
│   │       ├── internal/
│   │       │   ├── config/
│   │       │   ├── logic/
│   │       │   │   ├── getvideoinfologic.go
│   │       │   │   ├── batchgetvideoinfologic.go
│   │       │   │   ├── getvideostatlogic.go
│   │       │   │   └── getvideollistlogic.go
│   │       │   ├── server/
│   │       │   │   └── videoserver.go
│   │       │   ├── svc/
│   │       │   │   └── servicecontext.go
│   │       │   └── dao/
│   │       │       └── video.go          # 数据访问层
│   │       ├── pb/
│   │       │   └── video.pb.go
│   │       ├── video.proto
│   │       └── video.go
│   │
│   └── hotrank/                           # 热门排行榜服务（核心）
│       ├── rpc/                           # RPC接口（给API层调用）
│       │   ├── etc/
│       │   │   └── hotrank.yaml
│       │   ├── internal/
│       │   │   ├── config/
│       │   │   ├── logic/
│       │   │   │   ├── getglobalrankinglogic.go
│       │   │   │   ├── getregionrankinglogic.go
│       │   │   │   └── batchupdatehotlogic.go
│       │   │   ├── server/
│       │   │   ├── svc/
│       │   │   └── dao/
│       │   │       └── hotrank.go
│       │   ├── pb/
│       │   ├── hotrank.proto
│       │   └── hotrank.go
│       │
│       └── job/                           # 定时任务（热度计算）⭐核心
│           ├── etc/
│           │   └── hotrank-job.yaml
│           ├── internal/
│           │   ├── config/
│           │   │   └── config.go
│           │   ├── dao/
│           │   │   ├── academy.go         # 热度表DAO（参考主项目）
│           │   │   └── video.go           # 视频RPC调用
│           │   ├── model/
│           │   │   └── model.go
│           │   ├── service/
│           │   │   ├── service.go         # 主服务（参考主项目）
│           │   │   └── academy.go         # 热度计算逻辑（参考主项目）
│           │   └── svc/
│           │       └── servicecontext.go
│           └── hotrankjob.go
│
├── common/                                 # 公共组件
│   ├── model/                             # 数据模型
│   │   ├── hotrankmodel/                  # go-zero sqlc 生成
│   │   └── videomodel/
│   ├── xerr/                              # 错误码
│   │   └── errcode.go
│   └── tool/                              # 工具函数
│       └── xstr.go                        # 字符串工具（如 JoinInts）
│
├── deploy/
│   ├── sql/
│   │   ├── 001_video.sql                 # 视频表
│   │   └── 002_hotrank.sql               # 热度表
│   ├── docker-compose.yml
│   └── Dockerfile
│
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

---

## 三、核心模块详细设计

### 3.1 热度计算任务（hotrank-job）⭐核心模块

> **设计理念**：完全参考主项目的实现，用 go-zero 重写

#### 3.1.1 Service 层

```go
// service/hotrank/job/internal/service/service.go
package service

import (
    "context"
    "sync"
    "time"
    
    "mybilibili/service/hotrank/job/internal/config"
    "mybilibili/service/hotrank/job/internal/dao"
    "mybilibili/service/video/rpc/videoclient"
    
    "github.com/zeromicro/go-zero/core/logx"
)

// Service 主服务（参考主项目）
type Service struct {
    c   config.Config
    arc *dao.VideoDao      // RPC客户端（调用video服务）
    aca *dao.AcademyDao    // 数据库DAO（热度表）
    wg  sync.WaitGroup
}

// New 初始化服务（参考主项目）
func New(c config.Config, videoRpc videoclient.Video) *Service {
    s := &Service{
        c:   c,
        arc: dao.NewVideoDao(videoRpc),
        aca: dao.NewAcademyDao(c.Mysql),
    }
    
    // 启动热度计算任务（参考主项目）
    if c.HotSwitch {
        go s.FlushHot(BusinessForVideo)    // 计算视频热度
        go s.FlushHot(BusinessForArticle)  // 计算专栏热度（暂不实现）
    }
    
    return s
}

// Close 关闭服务
func (s *Service) Close() {
    s.wg.Wait()
}
```

#### 3.1.2 热度计算逻辑（完全参考主项目）

```go
// service/hotrank/job/internal/service/academy.go
package service

import (
    "context"
    "math"
    "time"
    
    "mybilibili/service/hotrank/job/internal/model"
    "mybilibili/service/video/rpc/pb"
    
    "github.com/zeromicro/go-zero/core/logx"
)

const (
    BusinessForVideo   = 1
    BusinessForArticle = 2
)

// FlushHot 计算热度值（参考主项目的 FlushHot）
func (s *Service) FlushHot(bs int) {
    var (
        ctx   = context.Background()
        id    int64
        limit = 30  // 每批30条
    )
    
    for {
        // 1. 游标分页查询（参考主项目）
        arcs, err := s.aca.Archives(ctx, id, bs, limit)
        if err != nil {
            logx.Errorf("s.aca.Archives id(%d) error(%v)", id, err)
            return
        }
        
        count := len(arcs)
        if count == 0 {
            id = 0  // 重新从头开始（参考主项目）
            time.Sleep(time.Hour * 1)
            continue
        }
        
        // 2. 提取OID列表
        oids := make([]int64, 0)
        for _, a := range arcs {
            oids = append(oids, a.OID)
            id = a.ID  // 更新游标（参考主项目）
        }
        
        // 3. 批量计算热度（参考主项目）
        hots, err := s.computeHotByOIDs(ctx, oids, bs)
        if err != nil {
            logx.Errorf("s.computeHotByOIDs error(%v)", err)
            return
        }
        
        // 4. 批量更新数据库（参考主项目）
        if err := s.aca.UPHotByAIDs(ctx, hots); err != nil {
            logx.Errorf("s.aca.UPHotByAIDs hots(%+v) error(%v)", hots, err)
            return
        }
        
        logx.Infof("FlushHot success: processed %d videos, last_id=%d", count, id)
    }
}

// computeHotByOIDs 批量计算热度（参考主项目）
func (s *Service) computeHotByOIDs(ctx context.Context, oids []int64, bs int) (map[int64]int64, error) {
    res := make(map[int64]int64)
    
    if bs == BusinessForVideo {
        // 批量获取视频元数据（参考主项目）
        arcs, err := s.arc.Archives(ctx, oids)
        if err != nil {
            return nil, err
        }
        
        // 批量获取统计数据（参考主项目）
        stats, err := s.arc.Stats(ctx, oids)
        if err != nil {
            logx.Errorf("s.arc.Stats oids(%+v) error(%v)", oids, err)
            return nil, err
        }
        
        // 计算每个视频的热度（参考主项目）
        for _, oid := range oids {
            if arc, ok := arcs[oid]; ok && arc != nil {
                if stat, ok := stats[oid]; ok && stat != nil {
                    res[oid] = countArcHot(stat, arc.PubTime)
                }
            }
        }
    }
    
    return res, nil
}

// countArcHot 热度计算公式（完全参考主项目）
// 公式：硬币×0.4 + 收藏×0.3 + 弹幕×0.4 + 评论×0.4 + 播放×0.25 + 点赞×0.4 + 分享×0.6
// 新视频提权：24小时内发布的视频热度×1.5
func countArcHot(stat *pb.VideoStat, ptime int64) int64 {
    if stat == nil {
        return 0
    }
    
    // 多维度加权计算（完全参考主项目）
    hot := float64(stat.Coin)*0.4 +
           float64(stat.Fav)*0.3 +
           float64(stat.Danmaku)*0.4 +
           float64(stat.Reply)*0.4 +
           float64(stat.View)*0.25 +
           float64(stat.Like)*0.4 +
           float64(stat.Share)*0.6
    
    // 新视频提权（完全参考主项目）
    if ptime >= time.Now().AddDate(0, 0, -1).Unix() && ptime <= time.Now().Unix() {
        hot *= 1.5
    }
    
    return int64(math.Floor(hot))
}
```

#### 3.1.3 Academy DAO（参考主项目）

```go
// service/hotrank/job/internal/dao/academy.go
package dao

import (
    "context"
    "database/sql"
    "fmt"
    "time"
    
    "mybilibili/service/hotrank/job/internal/model"
    "mybilibili/common/tool"
    
    "github.com/zeromicro/go-zero/core/logx"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
)

const (
    // 查询SQL（参考主项目）
    _getArcsSQL = "SELECT id,oid,business FROM academy_archive WHERE state=? AND business=? AND id > ? ORDER BY id ASC LIMIT ?"
)

type AcademyDao struct {
    conn sqlx.SqlConn
}

func NewAcademyDao(conn sqlx.SqlConn) *AcademyDao {
    return &AcademyDao{
        conn: conn,
    }
}

// Archives 游标分页查询（完全参考主项目）
func (d *AcademyDao) Archives(ctx context.Context, id int64, bs, limit int) ([]*model.OArchive, error) {
    var res []*model.OArchive
    
    err := d.conn.QueryRowsCtx(ctx, &res, _getArcsSQL, 0, bs, id, limit)
    if err != nil {
        logx.Errorf("QueryRows error(%v)", err)
        return nil, err
    }
    
    return res, nil
}

// UPHotByAIDs 批量更新热度值（完全参考主项目的 CASE WHEN 实现）
func (d *AcademyDao) UPHotByAIDs(ctx context.Context, hots map[int64]int64) error {
    var oids []int64
    
    // 构建 CASE WHEN SQL（参考主项目）
    sqlStr := "UPDATE academy_archive SET hot = CASE oid "
    for oid, hot := range hots {
        sqlStr += fmt.Sprintf("WHEN %d THEN %d ", oid, hot)
        oids = append(oids, oid)
    }
    sqlStr += fmt.Sprintf("END, mtime=? WHERE oid IN (%s)", tool.JoinInts(oids))
    
    _, err := d.conn.ExecCtx(ctx, sqlStr, time.Now())
    if err != nil {
        logx.Errorf("ExecCtx sql(%s) error(%v)", sqlStr, err)
        return err
    }
    
    logx.Infof("UPHotByAIDs success: updated %d records", len(hots))
    return nil
}
```

#### 3.1.4 Video DAO（RPC调用）

```go
// service/hotrank/job/internal/dao/video.go
package dao

import (
    "context"
    
    "mybilibili/service/video/rpc/videoclient"
    "mybilibili/service/video/rpc/pb"
    
    "github.com/zeromicro/go-zero/core/logx"
)

type VideoDao struct {
    videoRpc videoclient.Video
}

func NewVideoDao(videoRpc videoclient.Video) *VideoDao {
    return &VideoDao{
        videoRpc: videoRpc,
    }
}

// Archives 批量获取视频元数据（参考主项目）
func (d *VideoDao) Archives(ctx context.Context, vids []int64) (map[int64]*pb.VideoInfo, error) {
    resp, err := d.videoRpc.BatchGetVideoInfo(ctx, &pb.BatchGetVideoInfoReq{
        Vids: vids,
    })
    if err != nil {
        logx.Errorf("videoRpc.BatchGetVideoInfo error(%v)", err)
        return nil, err
    }
    
    return resp.Infos, nil
}

// Stats 批量获取视频统计数据（参考主项目）
func (d *VideoDao) Stats(ctx context.Context, vids []int64) (map[int64]*pb.VideoStat, error) {
    resp, err := d.videoRpc.BatchGetVideoStat(ctx, &pb.BatchGetVideoStatReq{
        Vids: vids,
    })
    if err != nil {
        logx.Errorf("videoRpc.BatchGetVideoStat error(%v)", err)
        return nil, err
    }
    
    return resp.Stats, nil
}
```

#### 3.1.5 配置文件

```yaml
# service/hotrank/job/etc/hotrank-job.yaml
Name: hotrank-job

# 热度计算开关
HotSwitch: true

# MySQL 配置
Mysql:
  DataSource: root:password@tcp(127.0.0.1:3306)/mybilibili?charset=utf8mb4&parseTime=true

# Video RPC 配置
VideoRpc:
  Etcd:
    Hosts:
      - 127.0.0.1:2379
    Key: video.rpc

# 日志配置
Log:
  ServiceName: hotrank-job
  Mode: console
  Level: info

# 链路追踪
Telemetry:
  Name: hotrank-job
  Endpoint: http://localhost:14268/api/traces
  Sampler: 1.0
  Batcher: jaeger
```

#### 3.1.6 Main 入口

```go
// service/hotrank/job/hotrankjob.go
package main

import (
    "flag"
    "fmt"
    "os"
    "os/signal"
    "syscall"
    
    "mybilibili/service/hotrank/job/internal/config"
    "mybilibili/service/hotrank/job/internal/service"
    "mybilibili/service/hotrank/job/internal/svc"
    "mybilibili/service/video/rpc/videoclient"
    
    "github.com/zeromicro/go-zero/core/conf"
    "github.com/zeromicro/go-zero/core/logx"
    "github.com/zeromicro/go-zero/zrpc"
)

var configFile = flag.String("f", "etc/hotrank-job.yaml", "the config file")

func main() {
    flag.Parse()
    
    var c config.Config
    conf.MustLoad(*configFile, &c)
    
    // 初始化日志
    logx.MustSetup(c.Log)
    defer logx.Close()
    
    logx.Info("hotrank-job starting...")
    
    // 初始化 Video RPC 客户端
    videoRpc := videoclient.NewVideo(zrpc.MustNewClient(c.VideoRpc))
    
    // 初始化服务（参考主项目）
    svc := service.New(c, videoRpc)
    defer svc.Close()
    
    logx.Info("hotrank-job started")
    
    // 等待退出信号（参考主项目）
    ch := make(chan os.Signal, 1)
    signal.Notify(ch, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)
    for {
        sig := <-ch
        logx.Infof("get a signal %s", sig.String())
        switch sig {
        case syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:
            logx.Info("hotrank-job exit")
            return
        case syscall.SIGHUP:
            // TODO reload config
        default:
            return
        }
    }
}
```

---

### 3.2 视频服务（video-rpc）

#### 3.2.1 Proto 定义

```protobuf
// service/video/rpc/video.proto
syntax = "proto3";

package pb;
option go_package = "./pb";

service Video {
  // 获取视频信息
  rpc GetVideoInfo(GetVideoInfoReq) returns (GetVideoInfoResp);
  
  // 批量获取视频信息
  rpc BatchGetVideoInfo(BatchGetVideoInfoReq) returns (BatchGetVideoInfoResp);
  
  // 获取视频列表（游标分页）
  rpc GetVideoList(GetVideoListReq) returns (GetVideoListResp);
  
  // 获取视频统计数据
  rpc GetVideoStat(GetVideoStatReq) returns (GetVideoStatResp);
  
  // 批量获取统计数据
  rpc BatchGetVideoStat(BatchGetVideoStatReq) returns (BatchGetVideoStatResp);
}

message GetVideoInfoReq {
  int64 vid = 1;
}

message GetVideoInfoResp {
  VideoInfo info = 1;
}

message BatchGetVideoInfoReq {
  repeated int64 vids = 1;
}

message BatchGetVideoInfoResp {
  map<int64, VideoInfo> infos = 1;
}

message VideoInfo {
  int64 vid = 1;
  string title = 2;
  string cover = 3;
  int64 author_id = 4;
  string author_name = 5;
  int64 region_id = 6;
  int64 pub_time = 7;
  int32 duration = 8;
  string desc = 9;
  int32 state = 10;
}

message GetVideoListReq {
  int64 last_vid = 1;  // 游标
  int32 limit = 2;
}

message GetVideoListResp {
  repeated VideoData list = 1;
}

message VideoData {
  VideoInfo info = 1;
  VideoStat stat = 2;
}

message GetVideoStatReq {
  int64 vid = 1;
}

message GetVideoStatResp {
  VideoStat stat = 1;
}

message BatchGetVideoStatReq {
  repeated int64 vids = 1;
}

message BatchGetVideoStatResp {
  map<int64, VideoStat> stats = 1;
}

message VideoStat {
  int64 vid = 1;
  int64 view = 2;
  int64 like = 3;
  int64 coin = 4;
  int64 fav = 5;
  int64 share = 6;
  int64 reply = 7;
  int64 danmaku = 8;
}
```

---

### 3.3 数据库设计

#### 3.3.1 视频基础表

```sql
-- deploy/sql/001_video.sql
CREATE DATABASE IF NOT EXISTS mybilibili DEFAULT CHARACTER SET utf8mb4;

USE mybilibili;

-- 视频基本信息表
CREATE TABLE `video_info` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `vid` bigint NOT NULL COMMENT '视频ID',
  `title` varchar(255) NOT NULL COMMENT '标题',
  `cover` varchar(512) NOT NULL COMMENT '封面',
  `author_id` bigint NOT NULL COMMENT '作者ID',
  `author_name` varchar(64) NOT NULL COMMENT '作者名称',
  `region_id` int NOT NULL COMMENT '分区ID',
  `duration` int NOT NULL COMMENT '时长（秒）',
  `desc` text COMMENT '简介',
  `pub_time` bigint NOT NULL COMMENT '发布时间（Unix时间戳）',
  `state` tinyint NOT NULL DEFAULT 0 COMMENT '状态：0-正常，1-删除',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_vid` (`vid`),
  KEY `idx_author` (`author_id`),
  KEY `idx_region` (`region_id`),
  KEY `idx_pub_time` (`pub_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='视频基本信息表';

-- 视频统计表
CREATE TABLE `video_stat` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `vid` bigint NOT NULL COMMENT '视频ID',
  `view` bigint NOT NULL DEFAULT 0 COMMENT '播放数',
  `like_count` bigint NOT NULL DEFAULT 0 COMMENT '点赞数',
  `coin` bigint NOT NULL DEFAULT 0 COMMENT '硬币数',
  `fav` bigint NOT NULL DEFAULT 0 COMMENT '收藏数',
  `share` bigint NOT NULL DEFAULT 0 COMMENT '分享数',
  `reply` bigint NOT NULL DEFAULT 0 COMMENT '评论数',
  `danmaku` bigint NOT NULL DEFAULT 0 COMMENT '弹幕数',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_vid` (`vid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='视频统计表';
```

#### 3.3.2 热度排行榜表

```sql
-- deploy/sql/002_hotrank.sql
USE mybilibili;

-- 热度记录表（参考主项目的 academy_archive 表）
CREATE TABLE `academy_archive` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '自增ID（用于游标分页）',
  `oid` bigint NOT NULL COMMENT '对象ID（视频ID或专栏ID）',
  `hot` bigint NOT NULL DEFAULT 0 COMMENT '热度值',
  `business` tinyint NOT NULL DEFAULT 1 COMMENT '业务类型：1-视频，2-专栏',
  `region_id` int NOT NULL DEFAULT 0 COMMENT '分区ID',
  `pub_time` bigint NOT NULL COMMENT '发布时间',
  `state` tinyint NOT NULL DEFAULT 0 COMMENT '状态：0-正常，1-删除',
  `comment` varchar(255) DEFAULT '' COMMENT '备注',
  `ctime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `mtime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_oid` (`oid`),
  KEY `idx_business_state_id` (`business`, `state`, `id`),
  KEY `idx_hot_global` (`hot`, `state`),
  KEY `idx_hot_region` (`region_id`, `hot`, `state`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='热度排行榜表';
```

---

## 四、与主项目的核心差异

| 维度 | 主项目 Bilibili | MyBilibili | 原因 |
|-----|----------------|------------|------|
| **微服务框架** | Kratos | go-zero | 用户要求 |
| **RPC协议** | gorpc | gRPC | go-zero标准 |
| **服务发现** | discovery | etcd | go-zero内置 |
| **数据库封装** | go-common/sql | sqlx | go-zero生态 |
| **消息队列** | databus | go-queue | go-zero生态 |
| **配置格式** | toml | yaml | go-zero标准 |
| **日志库** | go-common/log | logx | go-zero内置 |
| **缓存层** | 无 | Redis | **性能优化** |
| **热度读取** | 直接查DB | 先查Redis | **性能优化** |

---

## 五、开发流程

### 5.1 第一阶段：基础设施（1天）

```bash
# 1. 初始化项目
mkdir -p mybilibili && cd mybilibili
go mod init mybilibili

# 2. 启动基础服务
cd deploy
docker-compose up -d mysql etcd jaeger

# 3. 初始化数据库
mysql -h127.0.0.1 -P3306 -uroot -p < sql/001_video.sql
mysql -h127.0.0.1 -P3306 -uroot -p < sql/002_hotrank.sql

# 4. 准备测试数据
mysql -h127.0.0.1 -P3306 -uroot -p < sql/003_test_data.sql
```

### 5.2 第二阶段：视频服务（2天）

```bash
# 1. 生成 proto 代码
cd service/video/rpc
goctl rpc protoc video.proto --go_out=. --go-grpc_out=. --zrpc_out=. --style go_zero

# 2. 生成 model 代码
cd ../../../common/model
goctl model mysql datasource -url="root:password@tcp(127.0.0.1:3306)/mybilibili" -table="video_info,video_stat" -dir=. --style go_zero

# 3. 实现业务逻辑
# - GetVideoInfo
# - BatchGetVideoInfo
# - GetVideoList（游标分页）
# - GetVideoStat
# - BatchGetVideoStat

# 4. 测试
go test ./...
```

### 5.3 第三阶段：热度计算任务（3天）⭐核心

```bash
# 1. 实现 academy DAO（参考主项目）
# - Archives() 游标分页查询
# - UPHotByAIDs() CASE WHEN 批量更新

# 2. 实现 video DAO
# - Archives() RPC调用
# - Stats() RPC调用

# 3. 实现 service 层（完全参考主项目）
# - FlushHot() 循环计算
# - computeHotByOIDs() 批量计算
# - countArcHot() 热度公式

# 4. 配置和启动
go run hotrankjob.go -f etc/hotrank-job.yaml

# 5. 验证
# 查看数据库 academy_archive 表的 hot 字段是否更新
```

### 5.4 第四阶段：API网关（2天）

```bash
# 1. 生成 API 代码
cd api/creative-api
goctl api go -api creative.api -dir . --style go_zero

# 2. 实现接口
# - 添加视频到热门池
# - 查询全站热门排行榜
# - 查询分区热门排行榜
# - 删除视频

# 3. 测试
curl http://localhost:8888/api/v1/academy/rank/global?page=1&page_size=20
```

---

## 六、关键代码示例（完全参考主项目）

### 6.1 游标分页查询（主项目风格）

```go
// 参考主项目的 _getArcsSQL
const _getArcsSQL = "SELECT id,oid,business FROM academy_archive WHERE state=? AND business=? AND id > ? ORDER BY id ASC LIMIT ?"

func (d *AcademyDao) Archives(ctx context.Context, id int64, bs, limit int) ([]*model.OArchive, error) {
    var res []*model.OArchive
    err := d.conn.QueryRowsCtx(ctx, &res, _getArcsSQL, 0, bs, id, limit)
    return res, err
}
```

### 6.2 CASE WHEN 批量更新（主项目风格）

```go
// 参考主项目的 UPHotByAIDs
func (d *AcademyDao) UPHotByAIDs(ctx context.Context, hots map[int64]int64) error {
    var oids []int64
    sqlStr := "UPDATE academy_archive SET hot = CASE oid "
    for oid, hot := range hots {
        sqlStr += fmt.Sprintf("WHEN %d THEN %d ", oid, hot)
        oids = append(oids, oid)
    }
    sqlStr += fmt.Sprintf("END, mtime=? WHERE oid IN (%s)", tool.JoinInts(oids))
    _, err := d.conn.ExecCtx(ctx, sqlStr, time.Now())
    return err
}
```

### 6.3 热度计算公式（主项目风格）

```go
// 完全参考主项目的 countArcHot
func countArcHot(stat *pb.VideoStat, ptime int64) int64 {
    if stat == nil {
        return 0
    }
    hot := float64(stat.Coin)*0.4 +
           float64(stat.Fav)*0.3 +
           float64(stat.Danmaku)*0.4 +
           float64(stat.Reply)*0.4 +
           float64(stat.View)*0.25 +
           float64(stat.Like)*0.4 +
           float64(stat.Share)*0.6
    if ptime >= time.Now().AddDate(0, 0, -1).Unix() && ptime <= time.Now().Unix() {
        hot *= 1.5
    }
    return int64(math.Floor(hot))
}
```

---

## 七、总结

### 7.1 设计亮点

1. **完全参考主项目**：核心算法、数据结构、流程设计完全一致
2. **框架适配**：用 go-zero 替代 Kratos，但保留核心设计模式
3. **简洁高效**：没有过度设计，保持主项目的简洁风格
4. **易于扩展**：预留了专栏、缓存、分区排行榜等扩展点

### 7.2 与主项目的一致性

| 核心特性 | 主项目 | MyBilibili | ✅ |
|---------|--------|------------|---|
| 游标分页 | ✅ | ✅ | ✅ |
| CASE WHEN批量更新 | ✅ | ✅ | ✅ |
| 热度计算公式 | ✅ | ✅ | ✅ |
| 新视频提权 | ✅ | ✅ | ✅ |
| 定时任务循环 | ✅ | ✅ | ✅ |
| RPC调用模式 | ✅ | ✅ | ✅ |
| Service层设计 | ✅ | ✅ | ✅ |
| DAO层分离 | ✅ | ✅ | ✅ |

### 7.3 下一步

1. **实现基础代码**：按照上面的设计完成编码
2. **单元测试**：编写测试用例，确保算法正确性
3. **性能测试**：验证千万级数据处理性能
4. **部署上线**：Docker化部署，配置监控告警

---

**准备开始编码了吗？我可以帮您生成具体的代码实现！**

