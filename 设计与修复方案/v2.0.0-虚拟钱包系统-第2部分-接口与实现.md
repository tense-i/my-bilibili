# MyBilibili 虚拟钱包系统设计方案 v2.0.0（第2部分）

## 五、Protobuf接口定义

### 5.1 wallet.proto

```protobuf
syntax = "proto3";

package wallet;
option go_package = "./wallet";

// 钱包服务
service Wallet {
  rpc Recharge(RechargeReq) returns(RechargeResp);
  rpc Pay(PayReq) returns(PayResp);
  rpc Exchange(ExchangeReq) returns(ExchangeResp);
  rpc GetDetail(GetDetailReq) returns(GetDetailResp);
  rpc GetStreamList(GetStreamListReq) returns(GetStreamListResp);
}

// 充值请求
message RechargeReq {
  int64 uid = 1;
  string coin_type = 2;      // gold/iap_gold
  int64 coin_num = 3;
  string transaction_id = 4;
  string extend_tid = 5;
  string platform = 6;       // ios/android/pc/h5
  int64 timestamp = 7;
  string biz_code = 8;
}

message RechargeResp {
  int64 gold = 1;
  int64 iap_gold = 2;
  int64 silver = 3;
}

// 消费请求
message PayReq {
  int64 uid = 1;
  string coin_type = 2;
  int64 coin_num = 3;
  string transaction_id = 4;
  string extend_tid = 5;
  string platform = 6;
  int64 timestamp = 7;
  string biz_code = 8;
}

message PayResp {
  int64 gold = 1;
  int64 iap_gold = 2;
  int64 silver = 3;
}

// 兑换请求
message ExchangeReq {
  int64 uid = 1;
  string src_coin_type = 2;
  int64 src_coin_num = 3;
  string dest_coin_type = 4;
  int64 dest_coin_num = 5;
  string transaction_id = 6;
  string platform = 7;
}

message ExchangeResp {
  int64 gold = 1;
  int64 iap_gold = 2;
  int64 silver = 3;
}

// 查询详情
message GetDetailReq {
  int64 uid = 1;
  string platform = 2;
}

message GetDetailResp {
  WalletDetail detail = 1;
}

message WalletDetail {
  int64 uid = 1;
  int64 gold = 2;
  int64 iap_gold = 3;
  int64 silver = 4;
  int64 gold_recharge_cnt = 5;
  int64 gold_pay_cnt = 6;
  int64 silver_pay_cnt = 7;
}

// 流水查询
message GetStreamListReq {
  int64 uid = 1;
  int64 offset = 2;
  int64 limit = 3;
}

message GetStreamListResp {
  repeated CoinStreamRecord list = 1;
  int64 total = 2;
}

message CoinStreamRecord {
  int64 id = 1;
  int64 uid = 2;
  string transaction_id = 3;
  int32 coin_type = 4;
  int64 delta_coin_num = 5;
  int64 org_coin_num = 6;
  int32 op_result = 7;
  int32 op_type = 8;
  string op_time = 9;
}
```

---

## 六、核心业务逻辑实现

### 6.1 充值Logic（完整参考主项目）

```go
// internal/logic/recharge_logic.go
package logic

import (
    "context"
    "fmt"
    "time"
    
    "mybilibili/app/wallet/cmd/rpc/internal/svc"
    "mybilibili/app/wallet/cmd/rpc/wallet"
    "mybilibili/app/wallet/model"
    "mybilibili/common/xerr"
    
    "github.com/zeromicro/go-zero/core/logx"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
)

type RechargeLogic struct {
    ctx    context.Context
    svcCtx *svc.ServiceContext
    logx.Logger
}

func (l *RechargeLogic) Recharge(in *wallet.RechargeReq) (*wallet.RechargeResp, error) {
    // 1. 参数校验
    if in.Uid <= 0 || in.CoinNum <= 0 || in.TransactionId == "" {
        return nil, xerr.NewErrCode(xerr.REQUEST_PARAM_ERROR)
    }
    
    // 2. 币种转换（iOS用iap_gold）
    sysCoinType := model.GetSysCoinType(in.CoinType, in.Platform)
    sysCoinTypeNo := model.GetCoinTypeNumber(sysCoinType)
    
    // 3. 锁定TransactionID（防重复提交）
    tidLockKey := fmt.Sprintf("wallet:lock:tid:%s", in.TransactionId)
    ok, err := l.svcCtx.Redis.SetnxEx(tidLockKey, "locked", 300)
    if err != nil || !ok {
        l.Errorf("lock transaction id failed: %v", err)
        return nil, xerr.NewErrMsg("交易处理中，请勿重复提交")
    }
    defer l.svcCtx.Redis.Del(tidLockKey)
    
    // 4. 锁定用户（防并发修改）
    userLockKey := fmt.Sprintf("wallet:lock:user:%d", in.Uid)
    lockValue := fmt.Sprintf("locked:%d", time.Now().UnixNano())
    ok, err = l.svcCtx.Redis.Setnx(userLockKey, lockValue)
    if err != nil || !ok {
        return nil, xerr.NewErrMsg("账户操作中，请稍后重试")
    }
    l.svcCtx.Redis.Expire(userLockKey, 600)
    defer func() {
        val, _ := l.svcCtx.Redis.Get(userLockKey)
        if val == lockValue {
            l.svcCtx.Redis.Del(userLockKey)
        }
    }()
    
    // 5. 准备流水记录
    stream := &model.CoinStreamRecord{
        Uid:           in.Uid,
        TransactionId: in.TransactionId,
        ExtendTid:     in.ExtendTid,
        CoinType:      sysCoinTypeNo,
        DeltaCoinNum:  in.CoinNum,
        OpType:        model.OP_TYPE_RECHARGE,
        OpTime:        time.Now(),
        BizCode:       in.BizCode,
        Platform:      model.GetPlatformNumber(in.Platform),
        OpResult:      model.OP_RESULT_ADD_FAILED, // 默认失败
    }
    
    // 6. 执行数据库事务
    var wallet *model.UserWallet
    err = l.svcCtx.UserWalletModel.Trans(l.ctx, func(ctx context.Context, session sqlx.Session) error {
        // 6.1 FOR UPDATE查询（悲观锁）
        wallet, err = l.svcCtx.UserWalletModel.FindOneForUpdate(ctx, session, in.Uid)
        if err == model.ErrNotFound {
            // 首次充值，初始化钱包
            wallet = &model.UserWallet{
                Uid:    in.Uid,
                Gold:   0,
                IapGold: 0,
                Silver: 0,
            }
            _, err = l.svcCtx.UserWalletModel.Insert(ctx, session, wallet)
            if err != nil {
                return err
            }
        } else if err != nil {
            return err
        }
        
        // 记录原余额
        stream.OrgCoinNum = model.GetCoinByType(wallet, sysCoinTypeNo)
        
        // 6.2 UPDATE余额
        err = l.svcCtx.UserWalletModel.UpdateRecharge(ctx, session, in.Uid, sysCoinTypeNo, in.CoinNum)
        if err != nil {
            return err
        }
        
        // 6.3 INSERT流水记录（成功）
        stream.OpResult = model.OP_RESULT_ADD_SUCC
        _, err = l.svcCtx.CoinStreamRecordModel.Insert(ctx, session, stream)
        if err != nil {
            return err
        }
        
        // 更新内存中的wallet
        model.AddCoin(wallet, sysCoinTypeNo, in.CoinNum)
        return nil
    })
    
    if err != nil {
        l.Errorf("recharge transaction failed: %v", err)
        // 记录失败流水（异步）
        go l.svcCtx.CoinStreamRecordModel.Insert(context.Background(), nil, stream)
        return nil, xerr.NewErrCode(xerr.DB_ERROR)
    }
    
    // 7. 删除缓存
    l.svcCtx.WalletCache.Del(l.ctx, in.Uid)
    
    // 8. 发布钱包变更消息（Kafka）
    go l.publishWalletChange(in.Uid, "recharge", in.CoinType, in.CoinNum, wallet)
    
    // 9. 返回新余额
    return &wallet.RechargeResp{
        Gold:    wallet.Gold,
        IapGold: wallet.IapGold,
        Silver:  wallet.Silver,
    }, nil
}
```

### 6.2 消费Logic

```go
// internal/logic/pay_logic.go
func (l *PayLogic) Pay(in *wallet.PayReq) (*wallet.PayResp, error) {
    // 1-4同充值
    
    // 5. 准备流水
    stream := &model.CoinStreamRecord{
        Uid:           in.Uid,
        TransactionId: in.TransactionId,
        CoinType:      sysCoinTypeNo,
        DeltaCoinNum:  -in.CoinNum, // 负数
        OpType:        model.OP_TYPE_PAY,
        OpResult:      model.OP_RESULT_SUB_FAILED,
    }
    
    // 6. 数据库事务
    var wallet *model.UserWallet
    err = l.svcCtx.UserWalletModel.Trans(l.ctx, func(ctx context.Context, session sqlx.Session) error {
        // 6.1 FOR UPDATE
        wallet, err = l.svcCtx.UserWalletModel.FindOneForUpdate(ctx, session, in.Uid)
        if err != nil {
            return err
        }
        
        stream.OrgCoinNum = model.GetCoinByType(wallet, sysCoinTypeNo)
        
        // 6.2 余额检查（防超支）⭐关键
        if stream.OrgCoinNum < in.CoinNum {
            stream.OpReason = model.OP_REASON_NOT_ENOUGH
            // 记录失败流水
            _, _ = l.svcCtx.CoinStreamRecordModel.Insert(ctx, session, stream)
            return xerr.NewErrCode(xerr.COIN_NOT_ENOUGH)
        }
        
        // 6.3 UPDATE扣款
        err = l.svcCtx.UserWalletModel.UpdatePay(ctx, session, in.Uid, sysCoinTypeNo, in.CoinNum)
        if err != nil {
            return err
        }
        
        // 6.4 INSERT成功流水
        stream.OpResult = model.OP_RESULT_SUB_SUCC
        _, err = l.svcCtx.CoinStreamRecordModel.Insert(ctx, session, stream)
        if err != nil {
            return err
        }
        
        model.SubCoin(wallet, sysCoinTypeNo, in.CoinNum)
        return nil
    })
    
    if err != nil {
        if e, ok := err.(*xerr.CodeError); ok && e.GetErrCode() == xerr.COIN_NOT_ENOUGH {
            return nil, err // 余额不足，直接返回
        }
        l.Errorf("pay transaction failed: %v", err)
        return nil, xerr.NewErrCode(xerr.DB_ERROR)
    }
    
    // 7-9同充值
    l.svcCtx.WalletCache.Del(l.ctx, in.Uid)
    go l.publishWalletChange(in.Uid, "pay", in.CoinType, in.CoinNum, wallet)
    
    return &wallet.PayResp{
        Gold:    wallet.Gold,
        IapGold: wallet.IapGold,
        Silver:  wallet.Silver,
    }, nil
}
```

### 6.3 兑换Logic

```go
// internal/logic/exchange_logic.go
func (l *ExchangeLogic) Exchange(in *wallet.ExchangeReq) (*wallet.ExchangeResp, error) {
    // 1-4同充值
    
    // 5. 准备两条流水 + 一条兑换记录
    srcStream := &model.CoinStreamRecord{
        Uid:          in.Uid,
        TransactionId: in.TransactionId,
        CoinType:     srcCoinTypeNo,
        DeltaCoinNum: -in.SrcCoinNum, // 扣减
        OpType:       model.OP_TYPE_EXCHANGE,
        OpResult:     model.OP_RESULT_SUB_FAILED,
    }
    
    destStream := &model.CoinStreamRecord{
        Uid:          in.Uid,
        TransactionId: in.TransactionId,
        CoinType:     destCoinTypeNo,
        DeltaCoinNum: in.DestCoinNum, // 增加
        OpType:       model.OP_TYPE_EXCHANGE,
        OpResult:     model.OP_RESULT_ADD_FAILED,
    }
    
    exchangeRecord := &model.CoinExchangeRecord{
        Uid:           in.Uid,
        TransactionId: in.TransactionId,
        SrcCoinType:   srcCoinTypeNo,
        SrcCoinNum:    in.SrcCoinNum,
        DestCoinType:  destCoinTypeNo,
        DestCoinNum:   in.DestCoinNum,
        ExchangeRate:  float64(in.DestCoinNum) / float64(in.SrcCoinNum),
        Status:        0, // 默认失败
    }
    
    // 6. 数据库事务
    var wallet *model.UserWallet
    err = l.svcCtx.UserWalletModel.Trans(l.ctx, func(ctx context.Context, session sqlx.Session) error {
        // 6.1 FOR UPDATE
        wallet, err = l.svcCtx.UserWalletModel.FindOneForUpdate(ctx, session, in.Uid)
        if err != nil {
            return err
        }
        
        srcStream.OrgCoinNum = model.GetCoinByType(wallet, srcCoinTypeNo)
        destStream.OrgCoinNum = model.GetCoinByType(wallet, destCoinTypeNo)
        
        // 6.2 源币种余额检查
        if srcStream.OrgCoinNum < in.SrcCoinNum {
            srcStream.OpReason = model.OP_REASON_NOT_ENOUGH
            _, _ = l.svcCtx.CoinStreamRecordModel.Insert(ctx, session, srcStream)
            return xerr.NewErrCode(xerr.COIN_NOT_ENOUGH)
        }
        
        // 6.3 UPDATE原子兑换（一条SQL）⭐关键
        err = l.svcCtx.UserWalletModel.UpdateExchange(ctx, session, in.Uid,
            srcCoinTypeNo, in.SrcCoinNum, destCoinTypeNo, in.DestCoinNum)
        if err != nil {
            return err
        }
        
        // 6.4 INSERT两条流水
        srcStream.OpResult = model.OP_RESULT_SUB_SUCC
        _, err = l.svcCtx.CoinStreamRecordModel.Insert(ctx, session, srcStream)
        if err != nil {
            return err
        }
        
        destStream.OpResult = model.OP_RESULT_ADD_SUCC
        _, err = l.svcCtx.CoinStreamRecordModel.Insert(ctx, session, destStream)
        if err != nil {
            return err
        }
        
        // 6.5 INSERT兑换记录
        exchangeRecord.Status = 1
        _, err = l.svcCtx.CoinExchangeRecordModel.Insert(ctx, session, exchangeRecord)
        if err != nil {
            return err
        }
        
        model.SubCoin(wallet, srcCoinTypeNo, in.SrcCoinNum)
        model.AddCoin(wallet, destCoinTypeNo, in.DestCoinNum)
        return nil
    })
    
    if err != nil {
        l.Errorf("exchange transaction failed: %v", err)
        return nil, xerr.NewErrCode(xerr.DB_ERROR)
    }
    
    // 7-9同充值
    return &wallet.ExchangeResp{
        Gold:    wallet.Gold,
        IapGold: wallet.IapGold,
        Silver:  wallet.Silver,
    }, nil
}
```

---

## 七、Model层实现

### 7.1 user_wallet_model.go

```go
// app/wallet/model/user_wallet_model.go
package model

import (
    "context"
    "database/sql"
    "fmt"
    
    "github.com/zeromicro/go-zero/core/stores/cache"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
)

var (
    cacheUserWalletUidPrefix = "cache:wallet:uid:"
)

type (
    UserWalletModel interface {
        Insert(ctx context.Context, session sqlx.Session, data *UserWallet) (sql.Result, error)
        FindOne(ctx context.Context, uid int64) (*UserWallet, error)
        FindOneForUpdate(ctx context.Context, session sqlx.Session, uid int64) (*UserWallet, error)
        UpdateRecharge(ctx context.Context, session sqlx.Session, uid int64, coinType int32, amount int64) error
        UpdatePay(ctx context.Context, session sqlx.Session, uid int64, coinType int32, amount int64) error
        UpdateExchange(ctx context.Context, session sqlx.Session, uid int64, srcType int32, srcAmount int64, destType int32, destAmount int64) error
        Trans(ctx context.Context, fn func(context.Context, sqlx.Session) error) error
    }
    
    defaultUserWalletModel struct {
        sqlx.CachedConn
        table string
    }
    
    UserWallet struct {
        Uid              int64  `db:"uid"`
        Gold             int64  `db:"gold"`
        IapGold          int64  `db:"iap_gold"`
        Silver           int64  `db:"silver"`
        GoldRechargeCnt  int64  `db:"gold_recharge_cnt"`
        GoldPayCnt       int64  `db:"gold_pay_cnt"`
        SilverPayCnt     int64  `db:"silver_pay_cnt"`
        CostBase         int64  `db:"cost_base"`
        SnapshotTime     string `db:"snapshot_time"`
        SnapshotGold     int64  `db:"snapshot_gold"`
        SnapshotIapGold  int64  `db:"snapshot_iap_gold"`
        SnapshotSilver   int64  `db:"snapshot_silver"`
    }
)

func NewUserWalletModel(conn sqlx.SqlConn, c cache.CacheConf) UserWalletModel {
    return &defaultUserWalletModel{
        CachedConn: sqlx.NewCachedConn(conn, c),
        table:      "user_wallet",
    }
}

// 分表名
func (m *defaultUserWalletModel) getTableName(uid int64) string {
    return fmt.Sprintf("%s_%d", m.table, uid%10)
}

// FOR UPDATE查询
func (m *defaultUserWalletModel) FindOneForUpdate(ctx context.Context, session sqlx.Session, uid int64) (*UserWallet, error) {
    tableName := m.getTableName(uid)
    query := fmt.Sprintf("SELECT * FROM %s WHERE uid = ? FOR UPDATE", tableName)
    
    var resp UserWallet
    err := session.QueryRowCtx(ctx, &resp, query, uid)
    if err != nil {
        return nil, err
    }
    return &resp, nil
}

// UPDATE充值
func (m *defaultUserWalletModel) UpdateRecharge(ctx context.Context, session sqlx.Session, uid int64, coinType int32, amount int64) error {
    tableName := m.getTableName(uid)
    coinField := getCoinField(coinType)
    
    query := fmt.Sprintf(`
        UPDATE %s SET 
            %s = %s + ?,
            gold_recharge_cnt = gold_recharge_cnt + ?,
            snapshot_time = NOW()
        WHERE uid = ?
    `, tableName, coinField, coinField)
    
    _, err := session.ExecCtx(ctx, query, amount, amount, uid)
    return err
}

// UPDATE消费
func (m *defaultUserWalletModel) UpdatePay(ctx context.Context, session sqlx.Session, uid int64, coinType int32, amount int64) error {
    tableName := m.getTableName(uid)
    coinField := getCoinField(coinType)
    cntField := getPayCntField(coinType)
    
    query := fmt.Sprintf(`
        UPDATE %s SET 
            %s = %s - ?,
            %s = %s + ?
        WHERE uid = ?
    `, tableName, coinField, coinField, cntField, cntField)
    
    _, err := session.ExecCtx(ctx, query, amount, amount, uid)
    return err
}

// UPDATE兑换（一条SQL）
func (m *defaultUserWalletModel) UpdateExchange(ctx context.Context, session sqlx.Session, uid int64, 
    srcType int32, srcAmount int64, destType int32, destAmount int64) error {
    
    tableName := m.getTableName(uid)
    srcField := getCoinField(srcType)
    destField := getCoinField(destType)
    srcCntField := getPayCntField(srcType)
    
    query := fmt.Sprintf(`
        UPDATE %s SET 
            %s = %s - ?,
            %s = %s + ?,
            %s = %s + ?
        WHERE uid = ?
    `, tableName, srcField, srcField, destField, destField, srcCntField, srcCntField)
    
    _, err := session.ExecCtx(ctx, query, srcAmount, destAmount, srcAmount, uid)
    return err
}
```

---

**继续阅读：**
- 第3部分：分步实现计划、测试方案、部署方案
